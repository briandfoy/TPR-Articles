<ASCII-MAC>
<Version:5><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>>
<pstyle:Feature Lead>In the last issue, I went through my Perl program to merge the data from my Netflix queue and my cable TV provider. The next step in that process is scheduling my TiVo to record those programs, but I haven<0x2019>t automated that part yet. Once recorded, however, I have a program that downloads them from my TiVo and un-TiVos them for me. Once I have them, I can translate the files to the format that I need using ffmpeg.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Why not TiVo?	
<pstyle:Feature Section Lead>TiVo already provides a solution that does exactly the same job, but it only works on Windows. From the Windows software connects to my TiVo machine over my home network, authenticates itself, and downloads the shows I told it to download.
<pstyle:Feature Para>For some reason, their solution is incredibly slow. Not onyl that, my Windows box is a bit tempermental. It would work for a few weeks, then stop renewing its DHCP lease. That was probably something I had configured incorrectly, but I finally decided that the time I spent wrestling with Windows to make the TiVo software work would be better spent automating the task.
<pstyle:Feature Para>There are various other programs that attempt to do the same thing, but I could never get them to work correctly. Some wouldn<0x2019>t connect to my TiVo and others wouldn<0x2019>t download files. The situation might have improved since I stopped looking a year ago, but now I have a solution that works for me.
<pstyle:Feature Para>Lastly, as most Perl programmers will probably already be thinking, once I have my program working, I can make it do anything I like. I<0x2019>m not constrained by the GUIs of third-party software. I really just want something that runs without me having to do anything.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Downloading from TiVo	
<pstyle:Feature Section Lead>The TiVo box is connected to my home network and has an IP address just like any other machine. I<0x2019>ve configured my local DNS so that the host <CharStyle:pod-I>tivo.local<CharStyle:> points to my TiVo, and I<0x2019>ll use that hostname for the rest of the article. You<0x2019>ll have to figure out the address for your own box. I go to https://tivo.local/nowplaying/index.html, and when challenged for a username and password, I use <0x201C>tivo<0x201D> for the username and my Media Access Key (MAK) as the password. From that page, I can download shows.
<pstyle:Feature Para>I could write a WWW::Mechanize script, I guess, but that<0x2019>s a little too much work. The TiVo web server can also send my an XML document with everything I need to know so I don<0x2019>t have to crawl the website. I don<0x2019>t have to worry about that too much because the Net::TiVo takes care of all of that for me.
<pstyle:Feature Para>The Net::TiVo module only gives me access to the meta-data though. Once I get a list of the shows and their download links, I still need to get that data. Since I have the link, that<0x2019>s a simple matter of using LWP to handle the transaction for me. It<0x2019>s slightly tricky because the TiVo web server uses digest authentication.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> 	
<pstyle:Feature Section Lead>In Code Listing 1, I show the meat of the program. There are three major things I need to work out before I get down to business. I<0x2019>ll go through the main part of the program and show the subroutines later.
<pstyle:Feature Para>First, since I want my program to run over-and-over again, either from cron or the command line, I keep a DBM::Deep file around so I know which shows I<0x2019>ve already downloaded. I don<0x2019>t care to delete them from the TiVo once I<0x2019>ve downloaded them so I have the option of viewing them on TV or on my computer.
<pstyle:Feature Para>Second, I use Net::TiVo to get the XML data, although I don<0x2019>t care about the format since the module gives me an interface.
<pstyle:Feature Para>And last, I have my own user-agent that I create with LWP::UserAgent. It knows about the credentials and handles all
<pstyle:Feature Sub Section>Net::TiVo
<pstyle:Feature Para>At first I tried making my program without Net::TiVo. I can grab an XML file from the TiVo server and go through it myself, but there are few things I hate worse than processing XML on my own. On the other hand, I don<0x2019>t particularly like using two different objects to talk to the TiVo web server. When it comes down to it, I hate XML more. I<0x2019>ll suffer a bit of dirty design.
<pstyle:Feature Para>I construct the <CharStyle:pod-C>Net::TiVo<CharStyle:> object in <CharStyle:pod-C>$tivo<CharStyle:> by telling it the TiVo host and giving it my Media Access Key (MAK). To get the MAK, I looked in the TiVo settings \> Account & System Information \> Media Access Key. I<0x2019>ll need that key later too so I can decrypt the files I download.
<pstyle:Feature Para>Net::TiVo downloads the XML file for me automatically, discreetly handles the nasty XML bits, and gives me access to TiVo<0x2019>s information through methods. There are two levels to dig through: folders, which have nothing much to do with what I see in the TiVo interface, and shows, which live in the folders. Folders are really just groups of the same show. For instance, all of my recorded episodes of <CharStyle:pod-I>Top Gear<CharStyle:> would show up in a <CharStyle:pod-C>Top Gear<CharStyle:> folder.
<pstyle:Feature Para>Calling <CharStyle:pod-C>$tivo-<CharStyle:>folders\> gives me a list of of the folder objects. I<0x2019>ll loop through those with a foreach and put the current element in $folder. To get to the shows I need to get the list of shows with <CharStyle:pod-C>$folder-<CharStyle:>shows\>.
<pstyle:Feature Para>Once I have an element in <CharStyle:pod-C>$show<CharStyle:>, I have to determine if I want to download it. Things get a bit odd here. A show has a program_id, although that seems more like an episode_id since it identifies the episode, not the series. The <CharStyle:pod-C>Net::TiVo::Show<CharStyle:> module shows the various identifiers you can use. If I see that <CharStyle:pod-C>program_id<CharStyle:> in my <CharStyle:pod-C>DBM::Deep<CharStyle:> database, I<0x2019>ve already downloaded that episode so I<0x2019>ll skip it.
<pstyle:Feature Para>Before I<0x2019>ll download an episode, I<0x2019>ll print a short summary of its data. The download speed, despite the source and destination machines being on the same high speed network, is about real-time. That download speed doesn<0x2019>t matter much to me since all of this happens from a cron job and I<0x2019>m too busy to check any of the output until it fills up a disk.
<pstyle:Feature Para>Before I fetch the show, though, I<0x2019>ll take a step backward a bit and consider the user-agent I need to pass to <CharStyle:pod-C>fetch_show<CharStyle:>.
<pstyle:Feature Sub Section>The user-agent
<pstyle:Feature Para>There<0x2019>s nothing much interesting in the web bits of downloading TiVo files, save that TiVo uses digest authentication. Most people are use to the Basic authentication, which is as easy a string concatenation and encoding, but Digest is a bit more complicated. I don<0x2019>t even need to think about any of that though since <CharStyle:pod-C>LWP::UserAgent<CharStyle:> hides all of the complexity.
<pstyle:Feature Para>In <CharStyle:pod-I>Code Listing 2<CharStyle:>, I show the <CharStyle:pod-C>make_ua<CharStyle:>, I construct the user-agent. I immediately set it up with a session cookie jar by calling <CharStyle:pod-C>cookie_jar<CharStyle:> with a hash reference. I do that mostly by habit.
<pstyle:Feature Para>To handle the authentication, I make two calls to <CharStyle:pod-C>credentials<CharStyle:> so I can handle secure and unsecure HTTP. They both use the same realm, user, and password. Notice, however, that I don<0x2019>t have to say anything about the type of authentication. The magic of LWP handles it for me. It plugs the right information into whatever authentication scheme the server presents.
<pstyle:Feature Para>Now I have the user-agent I can fetch the show.
<pstyle:Feature Sub Section>Fetching a show
<pstyle:Feature Para><CharStyle:pod-I>Code Listing 3<CharStyle:>, <CharStyle:pod-C>fetch_show<CharStyle:> takes care of the mechanics of downloading the episode. These files are large. A half-hour program takes up about 900 Mb, so I don<0x2019>t want to do something simple such as reading the entire HTTP response into a scalar and then saving it to a file.
<pstyle:Feature Para>Since I have a user-agent object, I can tell LWP exactly how to download the file. The simplest (custom) thing is for <CharStyle:pod-C>$ua<CharStyle:> to save each chunk to a file as it arrives, so I only ever have a couple chunks in memory. When I call <CharStyle:pod-C>get<CharStyle:>, I give it an extra <CharStyle:pod-C>:content_file<CharStyle:> parameter to tell it where to save the file. That<0x2019>s merely the easy thing to do.
<pstyle:Feature Para>If I wanted to get a bit more fancy, I could also give <CharStyle:pod-C>get<CharStyle:> a <CharStyle:pod-C>:content_cb<CharStyle:> parameter that has a code reference as its value. If I did that, I could add a progress bar so I could watch the download progress in case I had nothing better to do. I<0x2019>d have to handle each chunk myself, but I can do anything else I would want to do too.
<pstyle:Feature Para>When I have the file, I ensure that it has the same size that the HTTP response advertised. If the file didn<0x2019>t fully transfer (perhaps because I filled up another disk, again), I delete the file.
<pstyle:Feature Para>At some point, with all of my free time, I should have my script let me know when the disk fills up, and not try to download further files. There<0x2019>s one more step, and its going to take up another big chunk of disk.
<pstyle:Feature Sub Section>Decoding the TiVo file
<pstyle:Feature Para>TiVo encrypts its files using the Media Access Key. The terms of use allow anyone to decrypt the files they recorded for their personal use. At the end of <CharStyle:pod-C>fetch_file<CharStyle:>, I call <CharStyle:pod-C>tivo_decode<CharStyle:>, which I show in <CharStyle:pod-I>Code Listing 4<CharStyle:>. It<0x2019>s not very complicated.
<pstyle:Feature Para>I don<0x2019>t want to take time to decode the file before downloading the next file. I fork another process to handle the decoding, and once forked, the child immediately execs to turn itself into the <CharStyle:pod-C>tivodecode<CharStyle:> program, which I found on Sourceforge. It turns the <CharStyle:pod-I>.TiVo<CharStyle:> file into an MPEG-2 file.
<pstyle:Feature Para>There is a final step that I don<0x2019>t handle in this script. On my Mac, Quicktime isn<0x2019>t espeically fond of MPEG-2, and the Apple codec I wasted $19 on doesn<0x2019>t make it any fonder. However, another cron job handles looks for new MPEG files. When it finds them, it sends them through <CharStyle:pod-I>ffmpeg<CharStyle:> to make them suitable for my iPhone.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Conclusion	
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> References	
<pstyle:Feature Section Lead><0x201C>Hacking the XML in Your TiVo<0x201D> by Bob DuCharme, <CharStyle:pod-I>http://www.xml.com/pub/a/2006/02/15/hacking-the-xml-in-your-tivo.html<CharStyle:>
<pstyle:Feature Para>tivodecode <CharStyle:pod-I>http://tivodecode.sourceforge.net/<CharStyle:>;
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> About the author	
<pstyle:Feature Section Lead>brian d foy is the publisher of <CharStyle:pod-I>The Perl Review<CharStyle:>.
