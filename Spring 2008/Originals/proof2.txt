<ASCII-MAC>
<Version:5><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>>
<DefineCharStyle:pod-I=<Nextstyle:pod-I><cColor:Black><cTypeface:Italic><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cLanguage:English\: USA><cUnderline:0><cFont:Minion \(T1\)><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineCharStyle:pod-C=<Nextstyle:pod-C><cColor:Black><cTypeface:Regular><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cUnderline:0><cFont:Courier New><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineCharStyle:pod-B=<Nextstyle:pod-B><cColor:Black><cTypeface:Bold><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cUnderline:0><cFont:Courier New><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineParaStyle:NormalParagraphStyle=<Nextstyle:NormalParagraphStyle>>
<DefineParaStyle:Feature Section=<BasedOn:NormalParagraphStyle><Nextstyle:Feature Section><cTypeface:Bold><cSize:10.000000><pSpaceBefore:4.500000><pTabRuler:20\,Left\,.\,0\,-\;258\,Left\,.\,0\,-\;><cFont:Rockwell><pGridAlign:BaseLine>>
<DefineParaStyle:Module Author Byline=<Nextstyle:Module Author Byline><cTypeface:Italic><cSize:9.500000><cLigatures:0><pDropCapCharacters:1><pDropCapLines:1><pHyphenationLadderLimit:0><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><cFont:Minion \(T1\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:Right><pGridAlign:BaseLine><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:Feature Lead=<Nextstyle:Feature Lead><cSize:9.500000><cLigatures:0><cTracking:50><pDropCapCharacters:1><pDropCapLines:3><pHyphenationLadderLimit:0><cLeading:11.400000><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><cFont:Minion \(T1\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:JustifyLeft><pGridAlign:BaseLine>>
<DefineParaStyle:Feature Para=<BasedOn:Feature Lead><Nextstyle:Feature Para><pDropCapLines:1><pFirstLineIndent:12.024000>>
<DefineParaStyle:Feature Section Lead=<BasedOn:Feature Para><Nextstyle:Feature Section Lead><pFirstLineIndent:0.000000><cLeading:-1.000000>>
<DefineParaStyle:Feature Code Para=<Nextstyle:Feature Code Para><cSize:9.500000><cLigatures:0><pHyphenationLadderLimit:0><pLeftIndent:10.799999><cLanguage:English\: USA><pHyphenation:0><pHyphenateCapitals:0><pHyphenationZone:0.000000><pTabRuler:18\,Left\,.\,0\,\;31.5\,Left\,.\,0\,\;45\,Left\,.\,0\,\;58.5\,Left\,.\,0\,\;72\,Left\,.\,0\,\;85.5\,Left\,.\,0\,\;99\,Left\,.\,0\,\;112.5\,Left\,.\,0\,\;126\,Left\,.\,0\,\;139.5\,Left\,.\,0\,\;153\,Left\,.\,0\,\;166.5\,Left\,.\,0\,\;180\,Left\,.\,0\,\;193.5\,Left\,.\,0\,\;207\,Left\,.\,0\,\;220.5\,Left\,.\,0\,\;234\,Left\,.\,0\,\;><cFont:Courier New><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pGridAlign:BaseLine>>
<DefineParaStyle:Feature Sub Section=<BasedOn:Feature Section><Nextstyle:Feature Sub Section><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News URL=<BasedOn:NormalParagraphStyle><Nextstyle:News URL><cSize:9.500000><pSpaceAfter:4.500000><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News para=<BasedOn:NormalParagraphStyle><Nextstyle:News para><cSize:9.500000><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News Headline=<BasedOn:NormalParagraphStyle><Nextstyle:News Headline><cTypeface:Bold><cSize:9.500000><pSpaceBefore:4.500000><cFont:Gill Sans \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar URL=<Nextstyle:Calendar URL><cTypeface:Italic><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar title=<Nextstyle:Calendar title><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar location=<Nextstyle:Calendar location><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar date=<Nextstyle:Calendar date><cTypeface:Bold><cSize:11.000000><cCase:All Caps><cLanguage:English\: USA><cFont:Gill Sans \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Feature Title=<Nextstyle:Feature Title><cSize:26.500000><cLeading:13.500000><cFont:Rockwell Extra Bold><pTextAlignment:Center>>
<DefineParaStyle:Feature Byline=<BasedOn:NormalParagraphStyle><Nextstyle:Feature Byline><cTypeface:Italic><cSize:11.000000><cLeading:13.000000><cFont:Gill Sans \(TT\)><pTextAlignment:Right>>
<DefineParaStyle:Feature Deck=<BasedOn:Feature Byline><Nextstyle:Feature Deck><cTypeface:Regular><pSpaceBefore:4.500000><pTextAlignment:Center>>
<DefineParaStyle:Normal=<Nextstyle:Normal><KeyboardShortcut:Shift\+Cmd\+Num 6><cSize:11.000000><cLigatures:0><pHyphenationLadderLimit:0><cLeading:13.000000><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><pSpaceBefore:4.500000><pSpaceAfter:4.500000><cFont:Arial \(TT\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:JustifyLeft>>
<DefineParaStyle:Body Copy=<BasedOn:Normal><Nextstyle:Body Copy><cSize:9.500000><pFirstLineIndent:12.024000><cLeading:-1.000000><pSpaceBefore:0.000000><pSpaceAfter:0.000000><cFont:Minion \(T1\)><pGridAlign:BaseLine><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:author byline=<BasedOn:Feature Para><Nextstyle:author byline><cTypeface:Italic><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:article head=<BasedOn:Normal><Nextstyle:Normal><KeyboardShortcut:Shift\+Cmd\+Num 1><cSize:14.000000><cHorizontalScale:1.100000><pSpaceBefore:13.500000><pSpaceAfter:0.000000><cFont:Arial Black><pKeepWithNext:4><cSkew:15.000000><pRuleBelowColor:Black><pRuleBelowTint:100.000000><pRuleBelowOffset:9.000000>>
<DefineParaStyle:article subhead=<BasedOn:article head><Nextstyle:article subhead><KeyboardShortcut:Shift\+Cmd\+Num 2><cSize:11.000000><pSpaceBefore:18.000000>>
<pstyle:Feature Lead>How do I know if what a Perl program is going to do without running it? Does it matter that its Perl instead of some other language? It turns out that the answer is related to the Halting Problem, which says that there is no <CharStyle:pod-I>general<CharStyle:> solution to the question if an arbitrary computer program will ever stop running. If I can<0x2019>t decide that, I can<0x2019>t perfectly analyze source code to figure out what it is doing without running it.
<pstyle:Feature Para>I first started thinking about this problem because it<0x2019>s a thorn-in-the-side for Adam Kennedy<0x2019>s PPI module, which attempts to parse Perl code without running it. PPI is the backbone of Perl::Critic, a tool to enforce code policy. Can PPI ever be 100% correct? I won<0x2019>t answer that question in this article, but I will go through the Halting Problem to show you how it applies to Perl. This is a first in a series of three articles that will eventually give you that answer.
<pstyle:Feature Para>These articles will avoid mathematical notation in favor of Perl 5. Perl 5 has its disadvantages for this work but it is an excellent way of presenting algorithms, in many ways much less awkward than the mathematical notations. I hope some readers, seeing the ideas in this form, will become comfortable enough with them to tackle them in more standard notation. If you decide you want to do that, Wikipedia is an excellent place to start.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Undecidability	
<pstyle:Feature Section Lead>A computer problem is <CharStyle:pod-I>undecidable<CharStyle:> if it<0x2019>s a decision about which of two sets an input falls into, and it<0x2019>s impossible to make that decision. Every computer problem can be seen as one or more decisions between two choices, so that all limits to decidability are limits to what can be done by computer. This is the first in a series of three articles about an insight that undecidability gives us into Perl, and the insights Perl gives us into undecidability.
<pstyle:Feature Para>These days computability and undecidability are treated as synonyms, but questions about decidability predate our modern notion of computing. The first person to formalize computability was Alan Turing, who introduced the Halting Problem. The Halting Problem is the problem of deciding whether a given computer with a given input runs forever or eventually halts. Turing didn<0x2019>t call it the the Halting Problem, but since his day it<0x2019>s gotten that name. Turing showed that the Halting Problem was uncomputable and therefore undecidable.
<pstyle:Feature Para>The Halting Problem is far from the only undecidable problem. There are many others, and it is not at all hard to run into them in everyday practice. It is usually obvious that an undecidable problem is going to be, at the least, very difficult. You often avoid them anyway, and in that case whether a problem is undecidable or merely just plain hard is a quibble. But there are also problems whose solution, if possible, justifies major resources. Knowing a problem is undecidable allows you to either redefine it or give up.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Borrow Your Cat?	
<pstyle:Feature Section Lead>There<0x2019>s a big problem with writing a proof in Perl. When you see Perl code, it raises a set of expectations. Most of those expectations are wrong when it comes to proofs. Perl code is usually written to <CharStyle:pod-B>do<CharStyle:> something. This code with this article is not. It is written to explore an idea. It is written as a thought problem.
<pstyle:Feature Para>The most famous example of a thought problem is Schr<0x00f6>dinger<0x2019>s cat. In it, you need a cat. You lock him in a box shielded not only from outside interference, but from outside observation. Inside this box you put another box. This inner box is not airtight, but it is shielded from interference by the cat. The inner box has a geiger counter triggered to detect atomic decays. The geiger counter has a relay which controls a hammer hanging over a flask, closed, fragile, and filled with a gas of high feline toxicity. Dr. Schr<0x00f6>dinger suggested hydrocyanic acid.
<pstyle:Feature Para>According to quantum mechanics, the geiger counter, as long as it is not observed, never trips the relay, never releases the hammer, never breaks the glass, and never kills the cat. But neither is the opposite true. You cannot say that the relay was tripped, that the hammer dropped, that the flask was broken, or that the cat is dead. The situation inside the box is a mixture of the two, not even a probability, but a kind of probability wannabe called a quantum superposition. When the box is opened the superposition collapses into a probability, the probability collapses into a fact, and the cat either either collapses dead or springs out of the box.
<pstyle:Feature Para>So what<0x2019>s up with the cat before the box is opened? That<0x2019>s the point of the problem. It doesn<0x2019>t really engage our intuition to be told that the decay state of an atom is a mathematical function involving complex numbers. To be told that about the trace a geiger counter leaves on its recording tape is a bit more of a challenge. But neither compares to the challenge involved in trying to envision a cat who is not alive, not dead, not in a transition from life to death, not in a transition from death to life, and not even in a state which is a red-blooded real-numbered probability of life or death. Now that<0x2019>s a challenge to our intuition.
<pstyle:Feature Para>If you think about Schr<0x00f6>dinger<0x2019>s cat like as an engineer, you will ask questions like: If the box is airtight, how does the cat breathe? If the box is not airtight, does the cat<0x2019>s respiration interact with the outside world? Doesn<0x2019>t that ruin the experiment? How do you calibrate the geiger counter? Since hydrocyanic acid remains liquid at room temperature, is it really the right choice? Isn<0x2019>t the bit with the hammer and the glass flask a bit Rube Goldbergish? Shouldn<0x2019>t you avoid having to deal with broken glass? And what about the SPCA? Asking any of these questions is a sign that you<0x2019>ve missed the point.
<pstyle:Feature Para>A thought problem can have major implementation issues and still work as a thought problem, as long as in principle it could be done. In fact, the difficulties from a practical point of view could be insuperable, and the thought problem will be none the worse. A thought problem can be also be far-fetched, grotesque and a very unreasonable thing to do.
<pstyle:Feature Sub Section>The Case of the Heath Robinson Programming Foundation
<pstyle:Feature Para>Let<0x2019>s suppose the Heath Robinson Programming Foundation (HRPF) recognizes Perl as its official language and decides to put its vast financial resources to work on improving what<0x2019>s available on CPAN. The first thing it decides it needs is an infinite loop detector.
<pstyle:Feature Para>The HRPF decides to hold a contest, with a handsome prize to be awarded to the best implementation of such a detector. The HRPF board wants the submissions culled before it picks finalists. You are offered an insultingly small grant to check that the infinite loop detectors work as specified in the contest rules. The times being what they are, you decide to take the offer.
<pstyle:Feature Para>I<0x2019>ve reserved <CharStyle:pod-C>Acme::Halt<CharStyle:> on the Comprehensive Perl Archive Network (CPAN). The rules require that the <CharStyle:pod-C>Acme::Halt<CharStyle:> module contain a function named <CharStyle:pod-C>halt<CharStyle:>. The first argument to <CharStyle:pod-C>halt<CharStyle:> is a code reference. It<0x2019>s the required argument. The remaining arguments are optional, and are treated as arguments to use when <CharStyle:pod-C>halt<CharStyle:> dereferences the code reference.
<pstyle:Feature Para>The function referenced by the first argument, with the arguments to <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> passed on to it, is the i\<test case\>. For example, when the call to <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> is
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    Acme::Halt::halt(\\&my_function, 42, 91, \\*STDERR)<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>then <CharStyle:pod-C>halt<CharStyle:> effectively runs <CharStyle:pod-C>my_function<CharStyle:> with the rest of the arguments:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    my_function(42, 91, \\*STDERR)<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para><CharStyle:pod-C>halt<CharStyle:> returns 1 if the test case halts, and it returns 0 if the test case runs forever. There<0x2019>s no requirement that <CharStyle:pod-C>halt<CharStyle:> actually run its test case. It may run it partially or not at all. There<0x2019>s no formal ban on <CharStyle:pod-C>halt<CharStyle:> running the test case completely, but <CharStyle:pod-C>halt<CharStyle:> must always return a result, and it can<0x2019>t do that if it tries to run an infinite loop to the end. At least sometimes, <CharStyle:pod-C>halt<CharStyle:> must analyze its test case without running it to completion.
<pstyle:Feature Para>The test cases must follow these rules:
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>no side effects<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Its behavior must depend only on its arguments<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>behavior must be the same with the same arguments<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>You might object that these restrictions turn the hard problem of finding infinite loops into three other problems, each one of which is even harder than the original problem. Bear in mind two things: a thought problem does not have to be a reasonable thing for anyone to want to do, and the HRPF has a lot of money to hand out.
<pstyle:Feature Sub Section>On to Work
<pstyle:Feature Para>I<0x2019>m expected to automate the process of checking entrants to the HRPF Infinite Loop Detector Contest. To get the first sub-pittance of my grant I need to submit my test plan with my Perl code. The result of my efforts is the code in Figure 1. The test case it uses is the function I have imaginatively named <CharStyle:pod-C>test_case<CharStyle:>, called with a reference to itself as its only argument.
<pstyle:Feature Para>My code doesn<0x2019>t seem to work right. I<0x2019>ve already run through the money I expect from the grant, and I<0x2019>ve got to submit something if I<0x2019>m to have any hope of paying the bills when they come.
<pstyle:Feature Para>Making my best attempt, I analyze the behavior of my test program. Here<0x2019>s what I find:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>                       Table 1
<pSpaceBefore:><pstyle:Feature Code Para>                   Summary of the Behavior of test_case(\\&test_case)
<pstyle:Feature Code Para>
<pstyle:Feature Code Para>                               What Acme::halt::halt     What actually happens
<pstyle:Feature Code Para>                               tells us                  at line 26
<pstyle:Feature Code Para>                               at line 7
<pstyle:Feature Code Para>
<pstyle:Feature Code Para> If Acme::Halt::halt
<pstyle:Feature Code Para> returns 0                     Loops                     Halts
<pstyle:Feature Code Para>
<pstyle:Feature Code Para> If Acme::Halt::halt
<pstyle:Feature Code Para><pSpaceAfter:4.500000> returns 1                     Halts                     Loops
<pSpaceAfter:><pstyle:Feature Para>In other words, whatever <CharStyle:pod-C>Acme::Halt::halt(\\&test_case, \\&test_case)<CharStyle:> says that <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:> is doing, it is actually doing the opposite. When the result of test says it should halt, the actual test case loops forever. When the result of test says it should loop forever, the actual test case halts.
<pstyle:Feature Para>You work out the details for the 91st time. Here<0x2019>s what you see.
<pstyle:Feature Code Para><pSpaceBefore:4.500000> Figure 1: Test Program for the HRPF Infinite Loop Detector Contest
<pSpaceBefore:><pstyle:Feature Code Para>
<pstyle:Feature Code Para>    1   use Acme::Halt;
<pstyle:Feature Code Para>    2
<pstyle:Feature Code Para>    3   # A routine to bust the fraudulent claimants
<pstyle:Feature Code Para>    4   sub test_case {
<pstyle:Feature Code Para>    5
<pstyle:Feature Code Para>    6	     my $arg = shift;
<pstyle:Feature Code Para>    7	     return 0 if Acme::Halt::halt($arg, $arg) == 0;
<pstyle:Feature Code Para>    8
<pstyle:Feature Code Para>    9	     # I don't reach this point unless there's no infinite
<pstyle:Feature Code Para>    10	     # loop according to Acme::Halt::halt
<pstyle:Feature Code Para>    11
<pstyle:Feature Code Para>    12	     # loop forever
<pstyle:Feature Code Para>    13	     my $threshold = 1024;
<pstyle:Feature Code Para>    14	     while (++$i) {
<pstyle:Feature Code Para>    15	         if ($i \> $threshold) {
<pstyle:Feature Code Para>    16	             $threshold *= 2;
<pstyle:Feature Code Para>    17	             warn q{if there's no infinite loop, why haven't I finished?};
<pstyle:Feature Code Para>    18	         }
<pstyle:Feature Code Para>    19	     }
<pstyle:Feature Code Para>    20
<pstyle:Feature Code Para>    21	     # NOTREACHED
<pstyle:Feature Code Para>    22
<pstyle:Feature Code Para>    23  }
<pstyle:Feature Code Para>    24
<pstyle:Feature Code Para>    25  # What does this routine do, if Acme::Halt::halt detects infinite loops?
<pstyle:Feature Code Para>    26  if (not test_case(\\&test_case)) {
<pstyle:Feature Code Para>    27      die('non-existent infinite loop reported by Acme::Halt::halt()');
<pstyle:Feature Code Para>    28  }
<pstyle:Feature Code Para>    29
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    30  # NOTREACHED
<pSpaceAfter:><pstyle:Head3Style><CharStyle:pod-C>Acme::Halt::halt<CharStyle:> Returns 0
<pstyle:Feature Para>Line 1 includes the <CharStyle:pod-C>Acme::Halt<CharStyle:> package. My test case, calling a routine named <CharStyle:pod-C>test_case<CharStyle:> with a reference to itself as its only argument, occurs at line 26.
<pstyle:Feature Para><CharStyle:pod-C>test_case<CharStyle:> shifts off its argument (line 6), which is a code reference to itself. <CharStyle:pod-C>test_case<CharStyle:> then calls <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> (line 7), passing its own argument on twice. The call to <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> at line 7 therefore amounts to a direct call to <CharStyle:pod-C>halt<CharStyle:> using the same reference as the first and second arguments:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>     Acme::Halt::halt(\\&test_case, \\&test_case)<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>What does <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> return? I<0x2019>m going to analyze both cases. I<0x2019>ll start with the simplest. Suppose <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> returns 0.
<pstyle:Feature Para>As noted in Table 1, If <CharStyle:pod-C>Acme::Halt::halt(\\&test_case, \\&test_case)<CharStyle:> returns 0, <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> is saying that c\<test_case\> calling itself does not halt; it runs forever.
<pstyle:Feature Para>As we can see from line 7, the 0 return from <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> also means we that we will return out of <CharStyle:pod-C>test_case<CharStyle:>. And that means we execute this <CharStyle:pod-C>die<CharStyle:> statement at line 27:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    die('non-existent infinite loop reported by Acme::Halt::halt()');<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>As your error message reports, there<0x2019>s a problem. At line 7 <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> reported that <CharStyle:pod-C>test_case(\\&test_case, \\&test_case)<CharStyle:> runs forever. But at line 26 it did <CharStyle:pod-B>not<CharStyle:> run forever. As noted in Table 1, what is reported at line 7 contradicts what happens at line 26.
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>   To here<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>What to do about it? You decide to defer your decision until you<0x2019>ve run through <CharStyle:pod-C>test_case<CharStyle:> again, this time seeing what happens if <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> returns 1.
<pstyle:Head3Style><CharStyle:pod-C>Acme::Halt::halt<CharStyle:> Returns 1
<pstyle:Feature Para>We run <CharStyle:pod-C>test_case<CharStyle:> again. Nothing is different until we hit line 7. We looked at what happens if <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> returns 0, this time let<0x2019>s look at what happens if the return value of <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> is 1. Here goes.
<pstyle:Feature Para>First off, if <CharStyle:pod-C>Acme::Halt::halt(\\&test_case, \\&test_case)<CharStyle:> returns 1, that means line 7 is saying that <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:> halts. In other words <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:> does <CharStyle:pod-B>not<CharStyle:> run forever.
<pstyle:Feature Para>A return of 1 from <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> also means the <CharStyle:pod-C>return<CharStyle:> on line 7 does not get executed and I fall through to line 13. As I can easily see, lines 13 through 19 are an infinite loop. Line 21 will never be reached. <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:> will never return.
<pstyle:Feature Para>Line 30 will also never be reached. In fact, I<0x2019>ll never leave the <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:> call in line 26.
<pstyle:Feature Para>The situation is as noted in Table 1. At line 26 <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:> loops forever. At line 7, <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> says that <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:> does <CharStyle:pod-B>not<CharStyle:> loop forever. Again lines 7 and 26 contradict each other.
<pstyle:Feature Para>As a test program, my code is a failure. I wonder how to fix it. I<0x2019>m awake, watching early morning TV, when a brilliant idea occurs to me. But before I get to it, let<0x2019>s talk about one mathematician<0x2019>s especially unsuccessful attempt to chat it up with a girl at a party.
<pstyle:Feature Sub Section>How Not to Hit It Off with a Girl at a Party
<pstyle:Feature Para>Once upon a time there was a beautiful, intelligent and well-educated ballerina. She spotted a mathematician at a party and instantly felt a strong attraction to him. Remember that thought problems can be far-fetched! She walked up to him and said, <0x201C>It must be wonderful to be able to do mathematics. I could never imagine following things like proofs.<0x201D> The mathematician insisted that, since she was very intelligent, she was certainly capable of not just understanding proofs, but of appreciating the beauty some of them have.
<pstyle:Feature Para>The mathematician had read Edna St. Vincent Millay. He some lines from one of her poems:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>                              Euclid alone
<pSpaceBefore:><pstyle:Feature Code Para> has looked on beauty bare. Fortunate they
<pstyle:Feature Code Para> Who, though once only and then but far away,
<pstyle:Feature Code Para><pSpaceAfter:4.500000> Have heard her massive sandal set on stone.
<pSpaceAfter:><pstyle:Feature Para>As he spoke, the mathematician felt more blood rushing to his face than he would have liked, but the ballerina either did not notice, or pretended not to. The mathematician recovered his composure and led the ballerina through Euclid<0x2019>s short, elegant proof that there are an infinite number of primes. (An extremely well-read woman, the ballerina already knew that a prime number is a number divisible only by itself and 1.)
<pstyle:Feature Para>The mathematician gazed into the ballerina<0x2019>s eyes. They were violet and registered shock. He asked her what part of the proof she<0x2019>d had a problem understanding. She told the mathematician she had understood him perfectly, thank you very much.
<pstyle:Feature Para>She pointed out to the mathematician that he had started by saying that if the primes were not infinite, there must be a fixed number of them, and that one of them must be the largest. That was OK, she said. But then he had pretended to believe there was a largest prime.
<pstyle:Feature Para>But, in fact, he didn<0x2019>t really believe in the largest prime. He only pretended to do so until he had created a contradiction. Once the mathematician had his contradiction, he had turned on his largest prime, blamed it for the contradiction, and showed that he had never really believed in his largest prime. She told the mathematician he was a vile little man, and that she would be glad to hear nothing more of him or his proofs. Then she turned around and walked out of his life forever.
<pstyle:Feature Sub Section>Desperate Men Do Desperate Things
<pstyle:Feature Para>In math, it<0x2019>s often the case that you<0x2019>re trying to prove something about something that<0x2019>s hard to get a handle on. Infinities are a hard thing to get a handle on, and Euclid had dealt with the issue of saying something about infinity by turning it into a statement about existence and non-existence--in this case, the non-existence of the largest prime. Non-existence is another thing that<0x2019>s hard to prove. You can show something exists with an example. Non-existence is trickier.
<pstyle:Feature Para>Mathematicians often turn statements of non-existence into statement about existence and work backwards. They show the existence of something creates a contradiction. That contradiction proves the thing never really existed.
<pstyle:Feature Para>In the pure form in which mathematicians do this kind of reasoning, it seems backwards, but they use this sort of logic all the time. Take the guy with the sure-fire investment scheme on TV. If it was that good, I say, he wouldn<0x2019>t be buying TV time to tell people. He<0x2019>d tell a few people at most, invest his and their money, and get rich, all the time going to great lengths to keep the secret. It<0x2019>s got to be a scam, I say. My reasoning went like this:
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>A<CharStyle:>: Assume that scheme in the infomercial is a sure-fire money maker.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>If A, then B<CharStyle:>: If it was a sure-fire money-making scheme, the people who knew about it would keep it a secret.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>Not B<CharStyle:>: They are not keeping it a secret.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>Therefore, not A<CharStyle:>: It is not a sure-fire money-making scheme.<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>This patttern occurs a lot in proofs:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>    A.  
<pSpaceBefore:><pstyle:Feature Code Para>    If A, then B.  
<pstyle:Feature Code Para>    Not B.  
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    Therefore, not A.
<pSpaceAfter:><pstyle:Feature Para>That<0x2019>s called a reduction to absurdity and math would be impossible without it. You assume something, then create a contradiction. Using that contradiction, you prove that the thing you assumed is not right.
<pstyle:Feature Para>In my late night TV meditation, Assumption A is that I<0x2019>m watching a sure-fire money making scheme. Contradiction B is the observation that people keep sure-fire money-making schemes secret.
<pstyle:Feature Para>###XXX: Might want to mention that both A and B are unproven assumptions
<pstyle:Feature Sub Section>My Problem Solved
<pstyle:Feature Para>I<0x2019>m laying back, basking in my immunity to the lure of late night scams, and admiring my own brilliance, when the solution to my halting investigations occurs to me.
<pstyle:Feature Para>I<0x2019>ve checked my HRPF Contest Entry test program a thousand times, so I know it all works, and that my test case satisfies the restrictions. But, I realize, there is one part of it that I do not know works. I don<0x2019>t know that the <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> program works as assumed.
<pstyle:Feature Para>So the situation comes down to this.
<pstyle:Feature Code Para><pSpaceBefore:4.500000> If (A) Acme::Halt::halt finds infinite loops,
<pSpaceBefore:><pstyle:Feature Code Para><pSpaceAfter:4.500000> then (B) your test program detects them in your test case.
<pSpaceAfter:><pstyle:Feature Para>But I also know this:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000> (Not B) Your test program does not detect infinite loops in your test case.<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>I realize that if I make <0x201C><CharStyle:pod-C>Acme::Halt::halt<CharStyle:> finds infinite loops<0x201D> my Assumption A, and <0x201C>test program detects loops in your test case<0x201D> my Contradiction B, and plug these into the formula for a <CharStyle:pod-I>reductio ad absurdam<CharStyle:>, then I get this:
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>A<CharStyle:>: Assume that <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> finds infinite loops.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>If A, then B<CharStyle:>: If <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> finds infinite loops, the test program finds them in its test case, <CharStyle:pod-C>test_case(\\&test_case)<CharStyle:>.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>Not B<CharStyle:>: Table 1 shows the the test program will not find infinite loops in the test case.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><CharStyle:pod-B>Therefore, not A<CharStyle:>: <CharStyle:pod-C>Acme::Halt::halt<CharStyle:> does not find infinite loops.<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>In this reasoning, the only assumption I made about <CharStyle:pod-C>Acme::Halt::halt<CharStyle:>, was that it obeys the restrictions imposed by the contest. So the logic above is valid for all possible contest entries--I don<0x2019>t even have to actually test them. No valid contest entry could possibly qualify as a finalist.
<pstyle:Feature Sub Section>Your Letter to the HRPF
<pstyle:Feature Para>In drafting up my letter to the HRPF telling them that there cannot possibly be a winning entrant to their contest, I point out that they could revise the contest. For example, it is obvious that a Perl script to simply output a message does not run forever:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>     say "goodnight, Gracie"<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>I could write a program that figures that out. A program might also be able to figure out this loops forever:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>     for (;;) { say "I'm bored." }<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>Programs to detect infinite loops can exist.
<pstyle:Feature Para>All I<0x2019>ve proved is that the <CharStyle:pod-B>general<CharStyle:> problem of finding infinite loops cannot be solved. It might be possible to detect a module which finds a lot of infinite loops. A module that detects 90%, or even 50%, of all infinite loops might still be useful. It<0x2019>s just that such a module will have to have some kind of failure rate. Perhaps it won<0x2019>t detect all infinite loops. Perhaps it will detect all infinite loops, but at the price of reporting false positives--infinite loops in code which doesn<0x2019>t have them.
<pstyle:Feature Para>I go on, in your letter to the HRPF, to say that actually, a determination that a contest is unwinnable amounts to a winning entry. So in addition to the pittance you were promised for qualifying entrants to the HRPF Infinite Loop Detector Contest you<0x2019>d like handsome sum they promised as first prize.
<pstyle:Head3Style>Laying it on Thicker
<pstyle:Feature Para>The HRPF Infinite Loop Contest entries did not have to work for arbitrary Perl functions. Those with side effects, those with dependences on the outside other than their arguments, and those which were non-deterministic, were excluded. What happens to the proof if they are considered?
<pstyle:Feature Para>All those factors were excluded because they made the infinite loop problem even harder to decide. Since the infinite loop problem is undecidable even without those functions in the mix, you can be sure it<0x2019>s not decidable if their behavior needs to be decided as well.
<pstyle:Feature Para>In fact, I tell the HRPF board, that these restrictions forced the proof to be especially strong--forced it to show that undecidability is not limited to situations which involve randomness, side effects, or outside dependencies. It shows their brilliance in framing the contest the way they did. On the same page, I include the address to which they can send the check for first prize.
<pstyle:Feature Para>Does the HRPF, overwhelmed with pride and gratitude, give me First Prize? I<0x2019>ll leave that to your imagination. Thought problems can be far-fetched, but there are limits to everything.
<pstyle:Feature Sub Section>In Defense of the Halting Problem
<pstyle:Feature Para>Mathematicians almost always prove a problem is undecidable by reducing it to the Halting Problem. The Halting Problem has tradition behind it. and infinite loops relate reasonably well to real life computing. But mathematicians often pretend they don<0x2019>t care about real life. They also use those horribly klunky Turing machines, with their read heads and squares marked on infinite length tapes. Is it because Theory of Computation professors are elitist jerks, focused on irrelevancies? That is certainly true of many of them, but it<0x2019>s not the real story.
<pstyle:Feature Para>When Turing formulated the Halting Problem, electronic computers did not exist. The term <0x201C>computer<0x201D> usually referred to a woman. A lot has changed since then. But do we really understand the central issues of our field so much better than Turing? Fifty years from now our models of computing will look as klunky as Turing<0x2019>s tapes and read heads. When it comes to thinking out the issues that will remain issues over the decades, current technology is not clearly superior.
<pstyle:Feature Para>Turing knew his physical technology could be superseded, something some of us perhaps forget about our own technology. Turing knew he was building ideas, and he built ideas that have lasted. Until we need a model of computing for which the Turing machines and the Halting Problem aren<0x2019>t adequate, why change?
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Conclusion	
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> References	
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> About the author	
<pstyle:Feature Section Lead>Jeffrey Kegler has been using Perl since 1987. At the time, he<0x2019>d bid a fixed-price gig and took a chance that the newly-released Perl 1 would be better than shell scripting. Betting on Larry Wall proved to be a good move.
<pstyle:Feature Para>Jeffrey is a published mathematician, has a BS and an MSCS from Yale, and was a Lecturer in the Yale Medical School. In 2007 he published his first novel, <CharStyle:pod-I>The God Proof<CharStyle:>. It centers on a little known part of Kurt Gšdel<0x2019>s work--his effort to prove God<0x2019>s existence. Gšdel worked out his proof in two notebooks, notebooks which were missing from his effects when they were cataloged after this death. <CharStyle:pod-I>The God Proof<CharStyle:> begins with Gšdel<0x2019>s lost notebooks reappearing in a coastal town in modern California. It<0x2019>s available as a free download: http://www.lulu.com/content/933192 . Print copies can be purchased at Amazon: http://www.amazon.com/God-Proof-Jeffrey-Kegler/dp/1434807355 .
