<ASCII-MAC>
<Version:5><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>>
<DefineCharStyle:pod-I=<Nextstyle:pod-I><cColor:Black><cTypeface:Italic><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cLanguage:English\: USA><cUnderline:0><cFont:Minion \(T1\)><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineCharStyle:pod-C=<Nextstyle:pod-C><cColor:Black><cTypeface:Regular><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cUnderline:0><cFont:Courier New><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineCharStyle:pod-B=<Nextstyle:pod-B><cColor:Black><cTypeface:Bold><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cUnderline:0><cFont:Courier New><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineParaStyle:NormalParagraphStyle=<Nextstyle:NormalParagraphStyle>>
<DefineParaStyle:Feature Section=<BasedOn:NormalParagraphStyle><Nextstyle:Feature Section><cTypeface:Bold><cSize:10.000000><pSpaceBefore:4.500000><pTabRuler:20\,Left\,.\,0\,-\;258\,Left\,.\,0\,-\;><cFont:Rockwell><pGridAlign:BaseLine>>
<DefineParaStyle:Module Author Byline=<Nextstyle:Module Author Byline><cTypeface:Italic><cSize:9.500000><cLigatures:0><pDropCapCharacters:1><pDropCapLines:1><pHyphenationLadderLimit:0><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><cFont:Minion \(T1\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:Right><pGridAlign:BaseLine><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:Feature Lead=<Nextstyle:Feature Lead><cSize:9.500000><cLigatures:0><cTracking:50><pDropCapCharacters:1><pDropCapLines:3><pHyphenationLadderLimit:0><cLeading:11.400000><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><cFont:Minion \(T1\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:JustifyLeft><pGridAlign:BaseLine>>
<DefineParaStyle:Feature Para=<BasedOn:Feature Lead><Nextstyle:Feature Para><pDropCapLines:1><pFirstLineIndent:12.024000>>
<DefineParaStyle:Feature Section Lead=<BasedOn:Feature Para><Nextstyle:Feature Section Lead><pFirstLineIndent:0.000000><cLeading:-1.000000>>
<DefineParaStyle:Feature Code Para=<Nextstyle:Feature Code Para><cSize:9.500000><cLigatures:0><pHyphenationLadderLimit:0><pLeftIndent:10.799999><cLanguage:English\: USA><pHyphenation:0><pHyphenateCapitals:0><pHyphenationZone:0.000000><pTabRuler:18\,Left\,.\,0\,\;31.5\,Left\,.\,0\,\;45\,Left\,.\,0\,\;58.5\,Left\,.\,0\,\;72\,Left\,.\,0\,\;85.5\,Left\,.\,0\,\;99\,Left\,.\,0\,\;112.5\,Left\,.\,0\,\;126\,Left\,.\,0\,\;139.5\,Left\,.\,0\,\;153\,Left\,.\,0\,\;166.5\,Left\,.\,0\,\;180\,Left\,.\,0\,\;193.5\,Left\,.\,0\,\;207\,Left\,.\,0\,\;220.5\,Left\,.\,0\,\;234\,Left\,.\,0\,\;><cFont:Courier New><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pGridAlign:BaseLine>>
<DefineParaStyle:Feature Sub Section=<BasedOn:Feature Section><Nextstyle:Feature Sub Section><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News URL=<BasedOn:NormalParagraphStyle><Nextstyle:News URL><cSize:9.500000><pSpaceAfter:4.500000><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News para=<BasedOn:NormalParagraphStyle><Nextstyle:News para><cSize:9.500000><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News Headline=<BasedOn:NormalParagraphStyle><Nextstyle:News Headline><cTypeface:Bold><cSize:9.500000><pSpaceBefore:4.500000><cFont:Gill Sans \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar URL=<Nextstyle:Calendar URL><cTypeface:Italic><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar title=<Nextstyle:Calendar title><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar location=<Nextstyle:Calendar location><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar date=<Nextstyle:Calendar date><cTypeface:Bold><cSize:11.000000><cCase:All Caps><cLanguage:English\: USA><cFont:Gill Sans \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Feature Title=<Nextstyle:Feature Title><cSize:26.500000><cLeading:13.500000><cFont:Rockwell Extra Bold><pTextAlignment:Center>>
<DefineParaStyle:Feature Byline=<BasedOn:NormalParagraphStyle><Nextstyle:Feature Byline><cTypeface:Italic><cSize:11.000000><cLeading:13.000000><cFont:Gill Sans \(TT\)><pTextAlignment:Right>>
<DefineParaStyle:Feature Deck=<BasedOn:Feature Byline><Nextstyle:Feature Deck><cTypeface:Regular><pSpaceBefore:4.500000><pTextAlignment:Center>>
<DefineParaStyle:Normal=<Nextstyle:Normal><KeyboardShortcut:Shift\+Cmd\+Num 6><cSize:11.000000><cLigatures:0><pHyphenationLadderLimit:0><cLeading:13.000000><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><pSpaceBefore:4.500000><pSpaceAfter:4.500000><cFont:Arial \(TT\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:JustifyLeft>>
<DefineParaStyle:Body Copy=<BasedOn:Normal><Nextstyle:Body Copy><cSize:9.500000><pFirstLineIndent:12.024000><cLeading:-1.000000><pSpaceBefore:0.000000><pSpaceAfter:0.000000><cFont:Minion \(T1\)><pGridAlign:BaseLine><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:author byline=<BasedOn:Feature Para><Nextstyle:author byline><cTypeface:Italic><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:article head=<BasedOn:Normal><Nextstyle:Normal><KeyboardShortcut:Shift\+Cmd\+Num 1><cSize:14.000000><cHorizontalScale:1.100000><pSpaceBefore:13.500000><pSpaceAfter:0.000000><cFont:Arial Black><pKeepWithNext:4><cSkew:15.000000><pRuleBelowColor:Black><pRuleBelowTint:100.000000><pRuleBelowOffset:9.000000>>
<DefineParaStyle:article subhead=<BasedOn:article head><Nextstyle:article subhead><KeyboardShortcut:Shift\+Cmd\+Num 2><cSize:11.000000><pSpaceBefore:18.000000>>
<pstyle:Feature Lead>Traditional idioms in Perl object-oriented programming (OOP) have severe problems and restrictions for inheritance that require the program to think about the internals of the modules they subclass. The Inside-Out approach fixes some of these but has problems of its own. My <CharStyle:pod-C>Alter<CharStyle:> module provides an alternative to both of these.
<pstyle:Feature Para>To work up to the <CharStyle:pod-C>Alter<CharStyle:> module, I need to start from the beginning. Once I go through the traditional approach and outline its shortcomings, I can show how Inside-Out objects get around those. Finally, that sets the stage for <CharStyle:pod-C>Alter<CharStyle:>.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Perl Objects	
<pstyle:Feature Section Lead>Three rules govern all object oriented programming in Perl. They set the framework for all class design, but they don<0x2019>t perscribe what an object looks like:
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>An <CharStyle:pod-I>object<CharStyle:> is simply a referenced thingy that happens to know which class it belongs to.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>A <CharStyle:pod-I>class<CharStyle:> is simply a package that happens to provide methods to deal with objects.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>A <CharStyle:pod-I>method<CharStyle:> is simply a subroutine that expects an object (or a package name, for class methods) as its first argument.<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>These rules give Perl programmers considerable freedom in their object design choices. Freedom is a good thing, but it has its price. In particular, the first rule with its flippantly vague <0x201C>referenced thingy<0x201D> allows me to choose the carrier of an object to be any of the data types that Perl allows. Scalars, arrays, hashes, globs, and even code references and regular expressions can be and have been used to incorporate objects.
<pstyle:Feature Para>This freedom is good. A Perl programmer thinks in terms of the three basic data types, scalar, array, or hash, and chooses the type that best represents the data. Since objects often represent data sets, it it would be awkward, though perfectly feasible, to restrict objects to only one of them.
<pstyle:Feature Para>The price of the freedom becomes apbase with inheritance. When class <CharStyle:pod-C>Derived<CharStyle:> inherits methods from a class <CharStyle:pod-C>Base<CharStyle:>, that means that I can call the methods of <CharStyle:pod-C>Base<CharStyle:> through <CharStyle:pod-C>Derived<CharStyle:> objects. The third rule, a method of <CharStyle:pod-C>Base<CharStyle:> is <0x201C>a subroutine that expects an object as its first argument.<0x201D> But to <CharStyle:pod-C>Base<CharStyle:>, <0x201C>object<0x201D> may mean, for instance, a hash reference while to <CharStyle:pod-C>Derived<CharStyle:> it may mean a scalar reference.
<pstyle:Feature Para>Mixing the two representations is fatal. If objects were spaceships and methods were crew, Perl objects might be be built by two aliens races who breath mutually lethal atmospheres. <0x201C>Hello commander, we have a case of inheritance here. Could one of your specialists help out?<0x201D> <0x201C>No way, Sir, sorry Sir. You<0x2019>re scalars, right? I lost a good man in an incident like that. <0x2019>Not a HASH reference<0x2019> were his last words.<0x201D>
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> The Traditional Approach	
<pstyle:Feature Section Lead>In practice, there are two styles of class implementation in Perl. The most common structures object data in named fields each of which can store a scalar. This is in accordance to other object oriented languages, where objects are like the structs of C or the records of other languages.
<pstyle:Feature Para>Hashes and arrays (with restrictions even scalars) can be used to implement this object model but by far the most common approach is to use a hash whose entries represent the fields. The key corresponds to the field name and the value holds the scalar content of the field. This <CharStyle:pod-I>hash-as-a-struct<CharStyle:> approach is so common, it may well be viewed as the standard class implementation in Perl. The basic structure looks like this, which I<0x2019>ll show more in a moment:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>sub new {
<pSpaceBefore:><pstyle:Feature Code Para>    my( $class, %args ) = @_;
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    ...;
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    bless \\%args, $class;
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    }
<pSpaceAfter:><pstyle:Feature Para>Other approaches may use a Perl data structure to represent the object directly, without dissecting the data into fields. As an example, suppose I want to implement a class whose objects are blocks of text; that is, a number of strings of equal length. I could implement that naturally as text blocks as arrays of strings. Basic accessors like <CharStyle:pod-C>height<CharStyle:> and <CharStyle:pod-C>width<CharStyle:> would report the number of lines and the length of any line, respectively. Outwardly, these accessors might impose as object <0x201C>fields<0x201D>, but I don<0x2019>t store their values in the object because I compute them when I need them. Indeed, it would be a pain store the height and width of a block somewhere else and keep them in sync with the actual text.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Traditional Shortcomings	
<pstyle:Feature Section Lead>These approaches have in common that they keep the object data in the object body. When it comes to inheritance among unrelated classes, this turns out to be a problem. Deadly accidents occur when the object types don<0x2019>t agree and I try to dereference it as the wrong type. Even if they happen to the situation is hardly better. The classes have to agree about the internal organization of data inside the object too. Thus, even two standard hash-as-a-struct classes might not be compatible unless their authors agreed which keys they will use. An array class like the one sketched for text blocks would be incompatible with any other use of the array for data storage.
<pstyle:Feature Para>Inheritance in Perl is mostly restricted to implementation-internal use. A class may use inheritance in its own implementation as long as the programmers adhere to a common standard. It does some social management. When it comes to publishing a class for public consumption, further inheritance is mostly a lost cause. This becomes apparent in view of the traditional lack of a separate initialization method.
<pstyle:Feature Para>A typical Perl class offers an object creator, a class method, often called <CharStyle:pod-C>new<CharStyle:>, that creates an object and initializes it according to given parameters:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>sub new {
<pSpaceBefore:><pstyle:Feature Code Para>    my( $class, %args ) = @_;
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    ...; # initialization happens here
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    bless \\%args, $class;
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    }
<pSpaceAfter:><pstyle:Feature Para>A separate object method, which would be called <CharStyle:pod-C>init<CharStyle:>, that initializes an already created object is rarely present:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>sub new {
<pSpaceBefore:><pstyle:Feature Code Para>    my( $class, %args ) = @_;
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    my $self = bless \\%args, $class;
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    $self-\>init; # now it's overrideable
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    $self;
<pstyle:Feature Code Para>    }
<pstyle:Feature Code Para>
<pstyle:Feature Code Para>
<pstyle:Feature Code Para>sub init {
<pstyle:Feature Code Para>    ...; # initialization happens here
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    }	
<pSpaceAfter:><pstyle:Feature Para>In a situation that involves inheritance, an object can only be created once, but must be initialized for all classes it inherits from. I need a separate initializer when my class is the base class. An inheritance-aware community would teach this in OOP kindergarten, along with the truism that <CharStyle:pod-C>new<CharStyle:> must bless objects into the given class, not its own.
<pstyle:Feature Para>Instead, the traditional class author resigns himself to the situation that to use a class as a base class, others have to investigate the internals of the base. They must initialize additional data in this semi-legal way. Since there is no other way, they don<0x2019>t see the need for a separate initializer.
<pstyle:Feature Para>The collaboration is simplified if a prospective base class clearly announces which of its methods access the object directly, and which don<0x2019>t. This is easy with field-oriented classes where it<0x2019>s good practice to define field accessors and then write all other methods in terms of these. A user has to override the accessors to be sure that the base will never try to access its body. If an undisciplined base class accesses the derived class<0x2019>s body all over the place, the derived class has to override, and thus re-implement, all these methods. That is not what the term <0x201C>code re-use<0x201D> means.
<pstyle:Feature Para>A base class can do more and specify a single method the derived class must override to be safe. For this purpose, the base defines a method that does nothing but pass on the object that calls it. It calls this method, gratuitously it seems, on every access to the object body, before it actually de-references it. This allows a user to base inheritance on a has-a relationship instead of the usual is-a one.
<pstyle:Feature Para>To be concrete, suppose a class <CharStyle:pod-C>Person<CharStyle:> wants to inherit from <CharStyle:pod-C>Name<CharStyle:>. <CharStyle:pod-C>Name<CharStyle:> has been so friendly to provide a method, probably called <CharStyle:pod-C>name<CharStyle:>, through which it does all its accesses. In <CharStyle:pod-C>name<CharStyle:> this method does nothing, it may be defined as a subroutine that just returns its first argument:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>sub name { shift }<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>The derived class, <CharStyle:pod-C>Person<CharStyle:>, has to maintain a <CharStyle:pod-C>Name<CharStyle:> object among its data that can be accessed by its overriding method called <CharStyle:pod-C>name<CharStyle:>. Whenever a <CharStyle:pod-C>Name<CharStyle:> method is called through a <CharStyle:pod-C>Person<CharStyle:> object, before every access to the <CharStyle:pod-C>Name<CharStyle:> internals the <CharStyle:pod-C>name<CharStyle:> method is called, which presents the right kind of object:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>package Person;
<pSpaceBefore:><pstyle:Feature Code Para>use base qw(Name);
<pstyle:Feature Code Para>
<pstyle:Feature Code Para>sub new {
<pstyle:Feature Code Para>    my( $class, ... ) = @_;
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para>    my $hash = { 
<pstyle:Feature Code Para>        Name =\> Name-\>new(...), 
<pstyle:Feature Code Para>        ...
<pstyle:Feature Code Para>        }
<pstyle:Feature Code Para>        
<pstyle:Feature Code Para>    bless $hash, $class;
<pstyle:Feature Code Para>    }
<pstyle:Feature Code Para>    
<pstyle:Feature Code Para><pSpaceAfter:4.500000>sub name { $_[0]-\>{Name} } #overrides
<pSpaceAfter:><pstyle:Feature Para>The technique can even be employed when the base class has not been so friendly as to jump through the access hoops described above. If the base is, say, an array object, the user class can overload hash dereferencing (<CharStyle:pod-C>@{}<CharStyle:>) and insert a method of its choosing into every access that considers the object to be an array.
<pstyle:Feature Para>If it inserts a method that presents the right kind of object (overloading <CharStyle:pod-C>@{}<CharStyle:> with <CharStyle:pod-C>name<CharStyle:> in the example), it can freely inherit all <CharStyle:pod-C>Name<CharStyle:> methods. This solution has obvious drawbacks. If the base and the derived classes have the same data type, it becomes a lot harder to implement. Also the use of overloading in general and dereference overloading in particular is problematic. While simple, the method is the opposite of effortless inheritance.
<pstyle:Feature Para>Summarily, inheritance can be managed with the traditional object model, but it does take management. The crux of the matter is that objects store their data in their body, and there is only one body to share for all classes involved. Effortless inheritance (so-called black-box inheritance) needs to find a way for classes to associate data with an object without relying on the type or content of the object body.
<pstyle:Feature Para>It is interesting to note that the three axioms of Perl OOP don<0x2019>t state explicitly where an object is supposed to store its data. Whether the omission is accidental or far-sighted is for history to decide.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> The Inside-out Approach	
<pstyle:Feature Section Lead>Inside-out classes use the <CharStyle:pod-I>reference address<CharStyle:> of an object as a unique identifier. The reference address of any Perl variable is unique at any time since it identifies the variable in a common address space. An inside-out class declares a lexical hash for each scalar field it wants to use with an object and uses the reference address as a key into this hash. I<0x2019>ll call hashes used in this way <CharStyle:pod-I>field hashes<CharStyle:>.
<pstyle:Feature Para>Inside-out classes associate individual values with an object in private field hashes that I can<0x2019>t access from outside the scope in which they are defined. I can only use the accessor methods the class chooses to compile within that scope. The only role of the object body is that of the carrier of a unique id. It doesn<0x2019>t matter what data type the body is or if it contains any data that might be used by other classes. An inside-out class stores its data outside of the body and never needs to dereference the object itself. By themselves, most inside-out classes use an undefined scalar as a token object body.
<pstyle:Feature Para>Compare this to the previous approach where an object is a hash that stores its values to storing data outside of the object. This inversion led to the name <CharStyle:pod-I>inside-out<CharStyle:>. This is also a psychological barrier when it comes to actually constructing inside-out classes. Perl programmers are used to seeing the object as a Perl data type that contains the object data. That<0x2019>s not true for inside-out objects.
<pstyle:Feature Para>Here<0x2019>s an example from David Golden<0x2019>s <CharStyle:pod-C>Class::InsideOut<CharStyle:>. The <CharStyle:pod-C>new<CharStyle:> method simply registers a new object, but it stores the object data in the object-external variables <CharStyle:pod-C>%name<CharStyle:>, <CharStyle:pod-C>%ssn<CharStyle:>, and <CharStyle:pod-C>%age<CharStyle:>:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>package My::Class;
<pSpaceBefore:><pstyle:Feature Code Para> 
<pstyle:Feature Code Para>use Class::InsideOut qw( public readonly private register id );
<pstyle:Feature Code Para> 
<pstyle:Feature Code Para>public     name =\> my %name;    # accessor: name()
<pstyle:Feature Code Para>readonly   ssn  =\> my %ssn;     # read-only accessor: ssn()
<pstyle:Feature Code Para>private    age  =\> my %age;     # no accessor
<pstyle:Feature Code Para> 
<pstyle:Feature Code Para><pSpaceAfter:4.500000>sub new { register( shift ) }
<pSpaceAfter:><pstyle:Feature Para>With an inside-out object, I then have to access the object data by looking in the right external hash. The <CharStyle:pod-C>id<CharStyle:> method gets me the right key so I can access the value for that object:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>sub greeting {
<pSpaceBefore:><pstyle:Feature Code Para>    my $self = shift;
<pstyle:Feature Code Para>    return "Hello, my name is $name{ id $self }";
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    }
<pSpaceAfter:><pstyle:Feature Para>There are more concrete problems with the inside-out approach. During the run time of a program, I create objects and Perl destroys them when I<0x2019>m done with them. When a traditional object goes out of scope, Perl cleans up its data by the normal process of garbage collection because the data are part of the object. When an inside-out object goes out of scope its field hashes are unaffected and object data will continue to be stored under a now invalid reference address. This leads to memory leaks as I store data I can no longer access. Worse, Perl can reuse memory addresses. That<0x2019>s not a remote possibility; it happens all the time. If it happens with the address of a former object, the new one finds its data slots are not in pristine state but preset to the values the deceased object used to have.
<pstyle:Feature Para>So inside-out classes must define a destructor method that takes care of obsolete data. That is not a great hardship in itself. A class (<CharStyle:pod-I>i.e.<CharStyle:> its author) knows its field hashes and can easily delete the obsolete entries. But inside-out classes are there to support inheritance, and in the presence of multiple inheritance it is hard to make sure that I call all relevant destructors. The most common approach is to follow the <CharStyle:pod-C>@ISA<CharStyle:> tree and call all <CharStyle:pod-C>DESTROY<CharStyle:> methods found along the way. Since Perl, for better or worse, allows me to change <CharStyle:pod-C>@ISA<CharStyle:> at run time, there is no guarantee that the tree at destruction time represents the set of classes an object may have been initialized for.
<pstyle:Feature Para>A related problem exists with respect to thread-safety. When Perl starts a new thread, it clones all variables (named and anonymous) for use in a new interpreter run. That means that objects do what they are not supposed to do in inside-out theory: they change their reference address.
<pstyle:Feature Para>To be thread-safe an inside-out class must define a <CharStyle:pod-C>CLONE<CharStyle:> method that rectifies the situation. It must traverse all field hashes in the new thread and replace the entries referring to the parent thread with those that refer to the new clones. That implies some kind of object registry, usually a hash that associates the reference address of an object with a weak reference to the object proper. Thread safety with inside-out classes entails some serious my. On a brighter note, there is no problem in making sure your cloning method is actually called. Perl automatically calls every <CharStyle:pod-C>CLONE<CharStyle:> method from every class that has one.
<pstyle:Feature Para>Serialization of objects is another area of concern. Every aspiring inside-out programmer has at one time tried to use <CharStyle:pod-C>DATA::Dumper<CharStyle:> and <CharStyle:pod-C>print Dumper $obj<CharStyle:> with an object of suspect content, but got to see only a blessed undefined scalar. Of course, <CharStyle:pod-C>Data::Dumper<CharStyle:> knows nothing, and <CharStyle:pod-I>can<CharStyle:> know nothing about the lexical field hashes the class uses to store data.
<pstyle:Feature Para>General serializers, such as <CharStyle:pod-C>Data::Dumper<CharStyle:> and <CharStyle:pod-C>Storable<CharStyle:> and similar modules have only the object to work with. The strong encapsulation of inside-out allows no way of accessing the relevant field hashes from there. The logic is simple. Serialization, and de-serialization more so, break encapsulation. I can inspect the serialized string, or even alter it and create modified objects.
<pstyle:Feature Para>An inside-out class can provide its own plug-ins to handle <CharStyle:pod-C>Storable<CharStyle:> correctly (for <CharStyle:pod-C>Data::Dumper<CharStyle:> it<0x2019>s harder), but every class must do that for itself. The code has to be in a scope where the field hashes are visible. With multiple classes, there are similar problems ensuring Perl calls all the plugins, just as I noted earlier with destructors. Without additional means, like a central registry of all field hashes, it is impossible to write generic plugins that serialize an arbitrary inside-out object.
<pstyle:Feature Para>Programmers tackled this collection of problems in various ways and to various degrees in class-creating modules such <CharStyle:pod-C>Class::InsideOut<CharStyle:>, <CharStyle:pod-C>Object::InsideOut<CharStyle:> and <CharStyle:pod-C>Class::Std<CharStyle:> and, in a different approach, in the module <CharStyle:pod-C>Hash::Util::FieldHash<CharStyle:> (a core module as of Perl 5.10). The fact remains that these problems exist and additional measures are required to solve them.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> The Alter approach	
<pstyle:Feature Section Lead>The <CharStyle:pod-C>Alter<CharStyle:> module on CPAN offers an alternative. Like inside-out, it frees the object body from its duty as data storage, thereby allowing free inheritance. In contrast to inside-out objects, <CharStyle:pod-C>Alter<CharStyle:>-based object data are natively garbage-collected and objects are thread-safe.
<pstyle:Feature Para>It does this by installing a hidden data structure in each object that carries the class-specific data. This data structure, a hash I call the object<0x2019>s <CharStyle:pod-I>corona<CharStyle:>, I attach to the object by magic, in the technical sense of <CharStyle:pod-C>PERL_MAGIC_ext<CharStyle:>, which allows the addition of extra data. I key the corona by class name and store for each class a single scalar, usually a reference. The class uses this reference as a stand-in or <0x201C>alter ego<0x201D> for the object, for data storage. Another class gets to see a different slot in the corona, hence a different alter ego.
<pstyle:Feature Para>Specifically, the <CharStyle:pod-C>Alter<CharStyle:> module exports the primitives <CharStyle:pod-C>alter()<CharStyle:> and <CharStyle:pod-C>ego()<CharStyle:> to set and retrieve the class-specific reference each class wants to use in place of the object<0x2019>s actual body. The <CharStyle:pod-C>alter()<CharStyle:> function is typically called once in the lifetime of an object at initialization. I must call the <CharStyle:pod-C>ego()<CharStyle:> function before any data access, reading or writing, much like I just retreive the reference address of inside-out objects for data access. The opportunities for caching are also similar.
<pstyle:Feature Code Para><pSpaceBefore:4.500000>package MyClass;
<pSpaceBefore:><pstyle:Feature Code Para>use Alter ego =\> {}; # Alter ego of type hash
<pstyle:Feature Code Para>
<pstyle:Feature Code Para># Put data in it
<pstyle:Feature Code Para>my $obj = \\ do { my $o };
<pstyle:Feature Code Para>ego( $obj )-\>{a} = 1;
<pstyle:Feature Code Para>ego( $obj )-\>{b} = 2;
<pstyle:Feature Code Para>
<pstyle:Feature Code Para># Retrieve it again
<pstyle:Feature Code Para>print ego( $obj )-\>{ b}, "\\n"; # prints 2
<pstyle:Feature Code Para>
<pstyle:Feature Code Para>package OtherClass;
<pstyle:Feature Code Para>defined( ego $obj ) or die; # dies, OtherClass hasn't set an alter ego
<pstyle:Feature Code Para>
<pstyle:Feature Code Para>  # Direct access to the corona of alter egos
<pstyle:Feature Code Para>  my $crown = Alter::corona $obj;
<pstyle:Feature Code Para><pSpaceAfter:4.500000>  
<pSpaceAfter:><pstyle:Feature Para>On each call, <CharStyle:pod-C>alter()<CharStyle:> and <CharStyle:pod-C>ego()<CharStyle:> refer to the class determined by the package the calls are compiled into. In the normal course of things, code in a class accesses the class-specific slot of the corona and none other. For internal purposes, and for cases where class-specific access isn<0x2019>t good enough, the semi-official function <CharStyle:pod-C>Alter::corona<CharStyle:> gives me access to the entire corona of alter egos an object possesses. This function breaks encapsulation, as much of it as is provided by the <CharStyle:pod-C>Alter<CharStyle:> mechanism.
<pstyle:Feature Para>The <CharStyle:pod-C>Alter<CharStyle:> approach is close to the accustomed data model of Perl objects. An object can be any data structure the programmer wants it to be, as usual, only each class gets to see its <CharStyle:pod-I>own<CharStyle:> data structure. Consequently, the data type is determined at object initialization, not at object creation, an important distinction.
<pstyle:Feature Para><CharStyle:pod-C>Alter<CharStyle:> classes don<0x2019>t have to bother with <CharStyle:pod-C>DESTROY<CharStyle:> or <CharStyle:pod-C>CLONE<CharStyle:> methods because native Perl does it all. The reason is simply that magic is, and <CharStyle:pod-I>must be<CharStyle:>, supported by garbage collection and thread cloning. When an object dies, its corona dies with it, and when it is cloned, its corona is cloned, and that<0x2019>s it.
<pstyle:Feature Para>The serialization problem, however, persists. <CharStyle:pod-C>Storable<CharStyle:> and <CharStyle:pod-C>Data::Dumper<CharStyle:> are not magic-aware by themselves. <CharStyle:pod-C>Storable<CharStyle:> conceivably could be, but <CharStyle:pod-C>Data::Dumper<CharStyle:> re-constructs objects by evaluating Perl code and can<0x2019>t easily restore magic. However, the situation is more favorable with <CharStyle:pod-C>Alter<CharStyle:> objects. The object is more tightly coupled with its data, since the entire corona is, in principle, available when you have the object. This is where the privacy-breaking <CharStyle:pod-C>Alter::corona<CharStyle:> function comes in. It is used internally to provide hooks for <CharStyle:pod-C>Data::Dumper<CharStyle:> to produce readable output and for <CharStyle:pod-C>Storable<CharStyle:> to serialize and re-construct <CharStyle:pod-C>Alter<CharStyle:>-based objects. The actual object body, in case there is any to speak of, is also accounted for. These hooks are generic and work for all <CharStyle:pod-C>Alter<CharStyle:>-based classes. Per default, they are inherited by classes that <CharStyle:pod-C>use Alter<CharStyle:>.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> The future of Alter	
<pstyle:Feature Section Lead>In my entirely humble opinion the <CharStyle:pod-C>Alter<CharStyle:> technique ought to revolutionize Perl OOP. It reconciles the original object model <0x201C>An object is a reference ...<0x201D> with the requirements of free subclassing while keeping the additional fuzz to a minimum. Since object dumping and serialization are supported, class development with Alter isn<0x2019>t much different from the traditional approach. The resulting class can advertise itself as capable of becoming a base class of <CharStyle:pod-I>any<CharStyle:> other class, traditional, inside-out, or itself <CharStyle:pod-C>Alter<CharStyle:> based.
<pstyle:Feature Para>The one big fly in the ointment is that <CharStyle:pod-C>Alter<CharStyle:> is an <CharStyle:pod-C>XS<CharStyle:> module and would have to be a prerequisite of any class that builds on it. Users without a compiler (or without the right compiler) will be unable to use any such class. It will be hard for <CharStyle:pod-C>Alter<CharStyle:> to gain the critical mass of users that makes binary ports sprout.
<pstyle:Feature Para>The inside-out technique rests on a single primitive, <CharStyle:pod-C>Scalar::Util::refaddr<CharStyle:> which is available in core Perl. That is its one big advantage over <CharStyle:pod-C>Alter<CharStyle:>.
<pstyle:Feature Para>Perl programmers have learned to live without the kind of free inheritance that inside-out and <CharStyle:pod-C>Alter<CharStyle:> have to offer. Inheritance is used internally to construct classes, but nobody even thinks, for instance, of combining two arbitrary classes from CPAN in a common subclass. One would have to be extremely lucky, or invest major work, to make that happen. If at least one of the classes is freely inheritable, there is no problem.
<pstyle:Feature Para>Combination of foreign classes happens more often through other means like a <CharStyle:pod-I>has-a<CharStyle:> relation and <CharStyle:pod-I>delegation<CharStyle:>. Just how significant the advantages of free inheritance are is hard to say because there is no considerable corpus of such classes yet to prove the point.
<pstyle:Feature Para>Finally, if I<0x2019>m not entirely wrong, there is a feeling of fatigue in the Perl community about propositions to revolutionize Perl OOP. Nevertheless, I<0x2019>d like to project what could be done if the <CharStyle:pod-C>Alter<CharStyle:> technique became core Perl. The primitives <CharStyle:pod-C>alter<CharStyle:>, <CharStyle:pod-C>ego<CharStyle:> (and <CharStyle:pod-C>corona<CharStyle:>) could go into <CharStyle:pod-C>Scalar::Util<CharStyle:>, there<0x2019>s probably no need of a formal module. But why stop there? The use of the <CharStyle:pod-C>ego()<CharStyle:> function on object access could conceivably be made transbase by adding a particular kind of de-reference overloading to the existing <CharStyle:pod-C>overload<CharStyle:> module. It would have to kick in on <CharStyle:pod-I>every<CharStyle:> de-reference of an object and call the <CharStyle:pod-C>ego()<CharStyle:> function on the given object.
<pstyle:Feature Para>I haven<0x2019>t solved few problems with this approach (vague idea, rather). It is not clear how <0x201C>ego overloading<0x201D> should interact with the normal overloading of de-referencing. Also, it seems that it would be undesirable for <CharStyle:pod-C>ego<CharStyle:> overloading to be inheritable, the way normal overloading is. Unsuspecting classes that find themselves overloading all de-referencing may be in trouble if care is not taken. If the mechanism is to piggyback on the existing overload code, disabling inheritance may be a hard nut to crack if it is indeed necessary.
<pstyle:Feature Para>My intended type of object could be specified in the <CharStyle:pod-C>overload<CharStyle:> declaration, perhaps in this form:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    use overload ego =\> {};<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>And, isn<0x2019>t a syntax extension always the easiest part? Then the initialization of objects could make use of the fact that the alter ego is auto-created when needed, so the <CharStyle:pod-C>alter()<CharStyle:> function would not be strictly necessary. You<0x2019>d overload your object<0x2019>s <0x201C>ego<0x201D> with the desired data type and continue to write your class (mostly) like a conventional class whose objects <CharStyle:pod-I>are<CharStyle:> that data type.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> References	
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>http://www.stonehenge.com/merlyn/UnixReview/col63.html<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000><cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> About the Author	
