<ASCII-MAC>
<Version:5><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>>
<DefineCharStyle:pod-I=<Nextstyle:pod-I><cColor:Black><cTypeface:Italic><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cLanguage:English\: USA><cUnderline:0><cFont:Minion \(T1\)><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineCharStyle:pod-C=<Nextstyle:pod-C><cColor:Black><cTypeface:Regular><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cUnderline:0><cFont:Courier New><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineCharStyle:pod-B=<Nextstyle:pod-B><cColor:Black><cTypeface:Bold><cSize:9.500000><cHorizontalScale:1.000000><cTracking:0><cBaselineShift:0.000000><cCase:Normal><cStrokeColor:None><cUnderline:0><cFont:Courier New><cPosition:Normal><cStrikethru:0><cColorTint:-1.000000>>
<DefineParaStyle:NormalParagraphStyle=<Nextstyle:NormalParagraphStyle>>
<DefineParaStyle:Feature Section=<BasedOn:NormalParagraphStyle><Nextstyle:Feature Section><cTypeface:Bold><cSize:10.000000><pSpaceBefore:4.500000><pTabRuler:20\,Left\,.\,0\,-\;258\,Left\,.\,0\,-\;><cFont:Rockwell><pGridAlign:BaseLine>>
<DefineParaStyle:Module Author Byline=<Nextstyle:Module Author Byline><cTypeface:Italic><cSize:9.500000><cLigatures:0><pDropCapCharacters:1><pDropCapLines:1><pHyphenationLadderLimit:0><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><cFont:Minion \(T1\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:Right><pGridAlign:BaseLine><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:Feature Lead=<Nextstyle:Feature Lead><cSize:9.500000><cLigatures:0><cTracking:50><pDropCapCharacters:1><pDropCapLines:3><pHyphenationLadderLimit:0><cLeading:11.400000><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><cFont:Minion \(T1\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:JustifyLeft><pGridAlign:BaseLine>>
<DefineParaStyle:Feature Para=<BasedOn:Feature Lead><Nextstyle:Feature Para><pDropCapLines:1><pFirstLineIndent:12.024000>>
<DefineParaStyle:Feature Section Lead=<BasedOn:Feature Para><Nextstyle:Feature Section Lead><pFirstLineIndent:0.000000><cLeading:-1.000000>>
<DefineParaStyle:Feature Code Para=<Nextstyle:Feature Code Para><cSize:9.500000><cLigatures:0><pHyphenationLadderLimit:0><pLeftIndent:10.799999><cLanguage:English\: USA><pHyphenation:0><pHyphenateCapitals:0><pHyphenationZone:0.000000><pTabRuler:18\,Left\,.\,0\,\;31.5\,Left\,.\,0\,\;45\,Left\,.\,0\,\;58.5\,Left\,.\,0\,\;72\,Left\,.\,0\,\;85.5\,Left\,.\,0\,\;99\,Left\,.\,0\,\;112.5\,Left\,.\,0\,\;126\,Left\,.\,0\,\;139.5\,Left\,.\,0\,\;153\,Left\,.\,0\,\;166.5\,Left\,.\,0\,\;180\,Left\,.\,0\,\;193.5\,Left\,.\,0\,\;207\,Left\,.\,0\,\;220.5\,Left\,.\,0\,\;234\,Left\,.\,0\,\;><cFont:Courier New><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pGridAlign:BaseLine>>
<DefineParaStyle:Feature Sub Section=<BasedOn:Feature Section><Nextstyle:Feature Sub Section><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News URL=<BasedOn:NormalParagraphStyle><Nextstyle:News URL><cSize:9.500000><pSpaceAfter:4.500000><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News para=<BasedOn:NormalParagraphStyle><Nextstyle:News para><cSize:9.500000><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:News Headline=<BasedOn:NormalParagraphStyle><Nextstyle:News Headline><cTypeface:Bold><cSize:9.500000><pSpaceBefore:4.500000><cFont:Gill Sans \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pGridAlign:BaseLine><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar URL=<Nextstyle:Calendar URL><cTypeface:Italic><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar title=<Nextstyle:Calendar title><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar location=<Nextstyle:Calendar location><cSize:10.000000><cLanguage:English\: USA><cFont:Minion \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Calendar date=<Nextstyle:Calendar date><cTypeface:Bold><cSize:11.000000><cCase:All Caps><cLanguage:English\: USA><cFont:Gill Sans \(T1\)><pRuleAboveGapColor:None><pRuleBelowGapColor:None><pTextAlignment:Center><cUnderlineGapColor:None><cStrikeThroughGapColor:None><pWarichuAlignment:Left><rUseOTProGlyph:1><cRubyEdgeSpace:1>>
<DefineParaStyle:Feature Title=<Nextstyle:Feature Title><cSize:26.500000><cLeading:13.500000><cFont:Rockwell Extra Bold><pTextAlignment:Center>>
<DefineParaStyle:Feature Byline=<BasedOn:NormalParagraphStyle><Nextstyle:Feature Byline><cTypeface:Italic><cSize:11.000000><cLeading:13.000000><cFont:Gill Sans \(TT\)><pTextAlignment:Right>>
<DefineParaStyle:Feature Deck=<BasedOn:Feature Byline><Nextstyle:Feature Deck><cTypeface:Regular><pSpaceBefore:4.500000><pTextAlignment:Center>>
<DefineParaStyle:Normal=<Nextstyle:Normal><KeyboardShortcut:Shift\+Cmd\+Num 6><cSize:11.000000><cLigatures:0><pHyphenationLadderLimit:0><cLeading:13.000000><cLanguage:English\: USA><pHyphenation:0><pHyphenationZone:0.000000><pSpaceBefore:4.500000><pSpaceAfter:4.500000><cFont:Arial \(TT\)><pMaxLetterspace:0.050000><pMinLetterspace:-0.020000><pMaxGlyphScale:1.050000><pMinGlyphScale:0.950000><cHang:Baseline><pSingleWordAlignment:Left><pTextAlignment:JustifyLeft>>
<DefineParaStyle:Body Copy=<BasedOn:Normal><Nextstyle:Body Copy><cSize:9.500000><pFirstLineIndent:12.024000><cLeading:-1.000000><pSpaceBefore:0.000000><pSpaceAfter:0.000000><cFont:Minion \(T1\)><pGridAlign:BaseLine><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:author byline=<BasedOn:Feature Para><Nextstyle:author byline><cTypeface:Italic><bulFont:\<TextFont\>><bulTypeFace:\<TextStyle\>>>
<DefineParaStyle:article head=<BasedOn:Normal><Nextstyle:Normal><KeyboardShortcut:Shift\+Cmd\+Num 1><cSize:14.000000><cHorizontalScale:1.100000><pSpaceBefore:13.500000><pSpaceAfter:0.000000><cFont:Arial Black><pKeepWithNext:4><cSkew:15.000000><pRuleBelowColor:Black><pRuleBelowTint:100.000000><pRuleBelowOffset:9.000000>>
<DefineParaStyle:article subhead=<BasedOn:article head><Nextstyle:article subhead><KeyboardShortcut:Shift\+Cmd\+Num 2><cSize:11.000000><pSpaceBefore:18.000000>>
<pstyle:Feature Lead>Traditional idioms in Perl object-oriented programming (OOP) have severe problems and restrictions for inheritance that require the program to think about the internals of the modules they subclass. The Inside-Out approach fixes some of these but has problems of its own. My <CharStyle:pod-C>Alter<CharStyle:> module provides an alternative to both of these.
<pstyle:Feature Para>To work up to the <CharStyle:pod-C>Alter<CharStyle:> module, I need to start from the beginning. Once I go through the traditional approach and outline its shortcomings, I can show how Inside-Out objects get around those. Finally, that sets the stage for <CharStyle:pod-C>Alter<CharStyle:>.
<pstyle:Feature Sub Section>Perl Objects
<pstyle:Feature Para>Three rules govern all object oriented programming in Perl. They set the framework within which class design happens, but they don<0x2019>t describe in any detail what an object has to look like:
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>An <CharStyle:pod-I>object<CharStyle:> is simply a referenced thingy that happens to know which class it belongs to.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>A <CharStyle:pod-I>class<CharStyle:> is simply a package that happens to provide methods to deal with objects.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>A <CharStyle:pod-I>method<CharStyle:> is simply a subroutine that expects an object (or a package name, for class methods) as its first argument.<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>These give Perl programmers considerable freedom in their design choices. Freedom is a good thing, but as everyone knows it has its price.
<pstyle:Feature Para>In particular, the first rule with its flippantly vague <0x201C>referenced thingy<0x201D> allows to choose the carrier of an object to be any of the five or so data types that Perl allows. Scalars, arrays, hashes, globs, and even code references and regular expressions can be and have been used to incorporate objects.
<pstyle:Feature Para>This freedom is goode. A Perl programmer thinks in terms of the three basic data types, scalar, array, and hash and chooses the type that best represents the natural or imposed structure of a set of data. Since objects are supposed to represent data sets, it it would be awkward, though perfectly feasible, to restrict objects to only one of them.
<pstyle:Feature Para>The price of the freedom becomes apparent with inheritance. When class <CharStyle:pod-C>Derived<CharStyle:> inherits methods from a class <CharStyle:pod-C>Base<CharStyle:>, that means that the methods of <CharStyle:pod-C>Base<CharStyle:> can be called by <CharStyle:pod-C>Derived<CharStyle:> objects. In view of the third rule of Perl OO, a method of <CharStyle:pod-C>Base<CharStyle:> is <0x201C>a subroutine that expects an object as its first argument.<0x201D> But to <CharStyle:pod-C>Base<CharStyle:>, <0x201C>object<0x201D> may mean, for instance, a reference to a hash while to <CharStyle:pod-C>Derived<CharStyle:> it may mean a scalar reference. The result is fatal when a <CharStyle:pod-C>Base<CharStyle:> method tries to access the body of a <CharStyle:pod-C>Derived<CharStyle:> object.
<pstyle:Feature Para>If objects were spaceships and methods were crew, Perl objects might be be built by races that breath mutually lethal atmospheres. <0x201C>Hello commander, we have a case of inheritance here. Could one of your specialists help out?<0x201D> <0x201C>No way, Sir, sorry Sir. You<0x2019>re scalars, right? I lost a good man in an incident like that. <0x2019>Not a HASH reference<0x2019> were his last words.<0x201D>
<pstyle:Feature Sub Section>The Traditional Approach
<pstyle:Feature Para>In practice, there are two styles of class implementation in Perl. The most common one structures object data in named fields each of which can store a scalar. This is in accordance to other object oriented languages, where objects are like the structs of C or the records of other languages. Hashes and arrays (with restrictions even scalars) can be used to implement this object model but by far the most common approach is to use a hash whose entries represent the fields. The key corresponds to the field name and the value holds the scalar content of the field. This <CharStyle:pod-I>hash-as-a-struct<CharStyle:> approach is so common, it may well be viewed as the standard class implementation in Perl.
<pstyle:Feature Para>Other approaches may use a Perl data structure to represent the object directly, without dissecting the data into fields. As an example, suppose I want to implement a class whose objects are blocks of text, that is, a number of strings of equal length. It would be natural to implement text blocks as arrays of strings. Basic accessors like <CharStyle:pod-C>height<CharStyle:> and <CharStyle:pod-C>width<CharStyle:> would report the number of lines, and the length of any line, respectively. Outwardly, these accessors might impose as object <0x201C>fields<0x201D>, but their values are nowhere stored in the object, Perl maintains them for you. Indeed, it would be a pain store the height and width of a block somewhere else and keep them in sync with the actual text.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Traditional Shortcomings	
<pstyle:Feature Section Lead>These approaches have in common that they keep the object data in the object body. When it comes to inheritance among unrelated classes, this turns out to be a difficulty, to put it mildly. Deadly accidents occur when the object types don<0x2019>t agree, but even if they happen to the situation is hardly better. The classes would have to agree about the internal organization of data inside the object. Thus, even two standard hash-as-a-struct classes would not be compatible unless their authors agreed in some way or another which keys are to be used by each. An array class like the one sketched for text blocks would be incompatible with any other use of the array for data storage.
<pstyle:Feature Para>Therefore, inheritance in Perl has mostly been restricted to implementation-internal use. That is to say, a class may use inheritance in its own implementation, as long as the programmer(s) involved communicate or adhere to a common standard. Large projects can be managed that way, but it does take management. When it comes to publishing a class for common consumption, further inheritance is mostly treated as a lost cause. This becomes apparent in view of the traditional lack of a separate initialization method. Let me elaborate.
<pstyle:Feature Para>A typical Perl class offers an object creator, a class method, often called <CharStyle:pod-C>new<CharStyle:>, that creates an object and initializes it according to given parameters. A separate object method, which would be called <CharStyle:pod-C>init<CharStyle:>, that initializes an already created object is rarely present. In a situation that involves inheritance, an object can only be created once, but must be initialized for all classes it inherits from. Simple arithmetic dictates that a separate initializer is needed when a class wants to be used as a parent. An inheritance-aware community would teach this in OO kindergarten, along with the truism that <CharStyle:pod-C>new<CharStyle:> must bless objects into the given class, not its own.
<pstyle:Feature Para>Instead, the traditional class author has resigned to the situation that to use a class as a base class, clients have to investigate the internals of the base to a degree to accommodate themselves. Additional data will be initialized in this semi-legal way. Since there is no other way, the lack of a separate initializer isn<0x2019>t felt.
<pstyle:Feature Para>So inheritance requires collaboration of one sort or another. The collaboration is simplified if a prospective parent class clearly announces which of its methods access the object directly, and which don<0x2019>t. This is easily achieved with field oriented classes where it is good practice to define a set of field accessors and then write all other methods in terms of these. A client has to override the accessors, and nothing else, to be sure that the parent will never try to access its body. If an undisciplined parent class accesses its (i.e. the client<0x2019>s) body all over the place, the client has to override, and thus re-implement, all these methods. That is not what the term <0x201C>code re-use<0x201D> means.
<pstyle:Feature Para>A parent class can do more and specify a single method the client must override to be safe. For this purpose, the parent defines a method that does nothing but pass on the object that calls it. It calls this method, gratuitously it seems, on every access to the object body, before it actually de-references it. This allows a client to base inheritance on a has-a relationship. To be concrete, suppose a class <CharStyle:pod-C>Person<CharStyle:> wants to inherit from <CharStyle:pod-C>Name<CharStyle:>. <CharStyle:pod-C>Name<CharStyle:> has been so friendly to provide a method, probably called <CharStyle:pod-C>name<CharStyle:>, through which it does all its accesses. In <CharStyle:pod-C>name<CharStyle:> this method does nothing, it may be defined as <CharStyle:pod-C>sub name { shift }<CharStyle:>. The client, <CharStyle:pod-C>Person<CharStyle:> would have to maintain a <CharStyle:pod-C>Name<CharStyle:> object among its data that can be accessed by <CharStyle:pod-I>its<CharStyle:> overriding method called <CharStyle:pod-C>name<CharStyle:>. Whenever a <CharStyle:pod-C>Name<CharStyle:> method is called through a <CharStyle:pod-C>Person<CharStyle:> object, before every access to the <CharStyle:pod-C>Name<CharStyle:> internals the <CharStyle:pod-C>name<CharStyle:> method is called, which presents the right kind of object.
<pstyle:Feature Para>The technique can even be employed when the parent class has not been so friendly as to jump through the access hoops described above. If the parent is, say, an array object, the client class can <CharStyle:pod-I>overload<CharStyle:> hash dereferencing (<CharStyle:pod-C>@{}<CharStyle:>) and insert a method of its choosing into every access that considers the object to be an array. If it inserts a method that presents the right kind of object (overloading <CharStyle:pod-C>@{}<CharStyle:> with <CharStyle:pod-C><0x2019>name<0x2019><CharStyle:> in the example), it can freely inherit all <CharStyle:pod-C>Name<CharStyle:> methods. This <0x201C>solution<0x201D> has obvious drawbacks. If the parent and the client have the same data type, it becomes a lot harder to implement. Also the use of overloading in general and de-reference overloading in particular can be considered problematic. While simple, the method is rather the opposite of effortless inheritance.
<pstyle:Feature Para>Summarily, inheritance can be managed with the traditional object model, but it does take management. The crux of the matter is that objects store their data in their body, and there is only one body to share for all classes involved. Effortless inheritance (so-called black-box inheritance) needs to find a way for classes to associate data with an object without relying on the type or content of the object body.
<pstyle:Feature Para>It is interesting to note that the three axioms of Perl OOP don<0x2019>t state explicitly where an object is supposed to store its data. Whether the omission is accidental or far-sighted remains open.
<pstyle:Feature Sub Section>The Inside-out Approach
<pstyle:Feature Para>Inside-out classes use the <CharStyle:pod-I>reference address<CharStyle:> of an object as a unique identifier. The reference address of any Perl variable is unique at any time since it identifies the variable in a common address space. An inside-out class declares a lexical hash for each scalar field it wants to use with an object and uses the reference address (traditionally as a decimal number) as a key into this hash. I<0x2019>ll call hashes used in this way <CharStyle:pod-I>field hashes<CharStyle:>.
<pstyle:Feature Para>Inside-Out classes associate individual values with an object in private field hashes that I can<0x2019>t access from outside the scope they are defined in. I can only use the accessor methods the class chooses to compile within that scope. The only role of the object body is that of the carrier of a unique id. It doesn<0x2019>t matter what data type the body is, or if it contains any data (that might be used by other classes). An inside-out class stores its data outside of the body and never needs to de-reference the object itself. By themselves, most inside-out classes use an undefined scalar as a token object body.
<pstyle:Feature Para>Compare this to the standard approach where an object is a hash that stores its values in the object to storing data outside of the object. This inversion has led to the name <CharStyle:pod-I>inside-out<CharStyle:>. This is also a psychological barrier when it comes to actually constructing inside-out classes. Perl programmers are used to seeing the object as a Perl data type that contains the object data. That<0x2019>s not true for inside-out objects.
<pstyle:Feature Para>There are more concrete problems with the inside-out approach. During the run time of a program, objects are created and destroyed. When a traditional object of whatever type goes out of scope, its data (contained in the body) will be collected by the normal process of garbage collection. When an inside-out object goes out of scope its field hashes are unaffected and object data will continue to be stored under a now invalid reference address. Obviously hat can lead to memory leaks. Probably worse, memory addresses can be re-used by Perl. That<0x2019>s not only a remote possibility, it happens all the time. If it happens with the address of a former object, the new one my find its data slots not in pristine state but preset to the values the deceased object used to have.
<pstyle:Feature Para>So inside-out classes must define a destructor method that takes care of obsolete data. That is not a great hardship in itself. A class (<CharStyle:pod-I>i.e.<CharStyle:> its author) knows its field hashes and can easily delete the obsolete entries. But inside-out classes are there to support inheritance, and in the presence of multiple inheritance it is hard to make sure that all relevant destructors will be called. The most common approach is to follow the <CharStyle:pod-C>@ISA<CharStyle:> tree and call all <CharStyle:pod-C>DESTROY<CharStyle:> methods found along the way. Since Perl, for better or worse, allows the change of <CharStyle:pod-C>@ISA<CharStyle:> at run time, there is no guarantee that the tree at destruction time represents the set of classes an object may have been initialized for.
<pstyle:Feature Para>A related problem exists with respect to thread-safety. When Perl starts a new thread, all variables (named and anonymous) are cloned for use in a new interpreter run. That means that objects do what they are not supposed to do in inside-out theory: they change their reference address. To be thread-safe an inside-out class must define a <CharStyle:pod-C>CLONE<CharStyle:> method that rectifies the situation. It must traverse all field hashes in the new thread and replace the entries referring to the parent thread with those that refer to the new clones. That implies some kind of object registry, usually a hash that associates the reference address of an object with (a weak reference to) the object proper. Thread safety with inside-out classes entails some serious overhead. On a brighter note, there is no problem in making sure your cloning method is actually called. Perl calls every <CharStyle:pod-C>CLONE<CharStyle:> method from every class that has one.
<pstyle:Feature Para>Serialization of objects is another area of concern. Probably every aspiring inside-out programmer has at one time tried to use <CharStyle:pod-C>DATA::Dumper<CharStyle:> and <CharStyle:pod-C>print Dumper $obj<CharStyle:> with an object of suspect content, but got to see only a blessed undefined scalar. Of course, <CharStyle:pod-C>Data::Dumper<CharStyle:> knows nothing, and <CharStyle:pod-I>can<CharStyle:> know nothing about the lexical field hashes the class uses to store data.
<pstyle:Feature Para>Serialization is used for inspection as above and, together with de-serialization, to implement object persistence, including object cloning. General serializes, like <CharStyle:pod-C>Data::Dumper<CharStyle:> and <CharStyle:pod-C>Storable<CharStyle:> and similar modules have only the object to work with. The strong encapsulation of inside-out allows no way of accessing the relevant field hashes from there. The logic is simple. Serialization, and de-serialization more so, break encapsulation. You can inspect the serialized string, or even alter it and create modified objects.
<pstyle:Feature Para>An inside-out class can provide its own plug-ins for <CharStyle:pod-C>Storable<CharStyle:> to be handled correctly (for <CharStyle:pod-C>Data::Dumper<CharStyle:> it<0x2019>s harder). But every class must do that for itself, the code has to be in a scope where the field hashes are visible. If multiple classes are involved, there are similar problems in getting all the plugins called as have been discussed with destructors. Without additional means, like central registry of all field hashes, it is impossible to write generic plugins that (de-)serialize an arbitrary inside-out object.
<pstyle:Feature Para>The collection of problems outlined above is tackled in various ways and to various degrees in class-creating modules like <CharStyle:pod-C>Class::InsideOut<CharStyle:>, <CharStyle:pod-C>Object::InsideOut<CharStyle:> and <CharStyle:pod-C>Class::Std<CharStyle:> and, in a different approach, in the module <CharStyle:pod-C>Hash::Util::FieldHash<CharStyle:>, core as of Perl 5.10. The fact remains that these problems exist and additional measures are required to solve them.
<pstyle:Feature Sub Section>The Alter approach
<pstyle:Feature Para>The <CharStyle:pod-C>Alter<CharStyle:> module on CPAN offers an alternative. Like inside-out, it frees the object body from its duty as data storage, thereby allowing free inheritance. In contrast to inside-out objects, <CharStyle:pod-C>Alter<CharStyle:> based object data are natively garbage-collected and objects are thread-safe.
<pstyle:Feature Para>It does this by installing a hidden data structure in each object that carries the class-specific data. This data structure, a hash called the object<0x2019>s <CharStyle:pod-I>corona<CharStyle:>, is attached to the object by magic, in the technical sense of <CharStyle:pod-C>PERL_MAGIC_ext<CharStyle:>, which allows the addition of extra data. The corona is keyed by class name and stores for each class a single scalar, usually a reference. The class uses this reference as a stand-in or <CharStyle:pod-I>alter ego<CharStyle:> for the object, to be used for data storage. Another class gets to see a different slot in the corona, hence a different alter ego.
<pstyle:Feature Para>Specifically, the <CharStyle:pod-C>Alter<CharStyle:> module exports the primitives <CharStyle:pod-C>alter()<CharStyle:> and <CharStyle:pod-C>ego()<CharStyle:> to set and retrieve the class-specific reference each class wants to use in place of the object<0x2019>s actual body. The <CharStyle:pod-C>alter()<CharStyle:> function is typically called once in the life-time of an object at initialization. The <CharStyle:pod-C>ego()<CharStyle:> function must be called before any data access, reading or writing, much like the reference address of inside-out objects must be retrieved for data access. The opportunities for caching are also similar.
<pstyle:Feature Para>On each call, <CharStyle:pod-C>alter()<CharStyle:> and <CharStyle:pod-C>ego()<CharStyle:> refer to the class determined by the package the calls are compiled into. In the normal course of things code in a class accesses the class-specific slot of the corona and none other. For internal purposes, and for cases where class-specific access isn<0x2019>t good enough, the semi-official function <CharStyle:pod-C>Alter::corona<CharStyle:> gives access to the entire corona of alter egos an object possesses. This function breaks encapsulation, as much of it as is provided by the <CharStyle:pod-C>Alter<CharStyle:> mechanism.
<pstyle:Feature Para>The <CharStyle:pod-C>Alter<CharStyle:> approach is close to the accustomed data model of Perl objects. An object can be any data structure the programmer wants it to be, as usual, only each class gets to see its <CharStyle:pod-I>own<CharStyle:> data structure. Consequently, the data type is determined at object initialization, not at object creation, an important distinction.
<pstyle:Feature Para><CharStyle:pod-C>Alter<CharStyle:> classes don<0x2019>t have to bother with <CharStyle:pod-C>DESTROY<CharStyle:> or <CharStyle:pod-C>CLONE<CharStyle:> methods because native Perl does it all. The reason is simply that magic is, <CharStyle:pod-I>must be<CharStyle:>, supported by garbage collection and thread cloning. When an object dies, its corona dies with it, and when it is cloned, its corona is cloned, and that<0x2019>s it.
<pstyle:Feature Para>The serialization problem, however, persists. <CharStyle:pod-C>Storable<CharStyle:> and <CharStyle:pod-C>Data::Dumper<CharStyle:> are not magic-aware by themselves. <CharStyle:pod-C>Storable<CharStyle:> conceivably could be, but <CharStyle:pod-C>Data::Dumper<CharStyle:> re-constructs objects by evaluating Perl code and can<0x2019>t easily restore magic. However, the situation is more favorable with <CharStyle:pod-C>Alter<CharStyle:> objects. The object is more tightly coupled with its data, since the entire corona is, in principle, available when you have the object. This is where the privacy-breaking <CharStyle:pod-C>Alter::corona<CharStyle:> function comes in. It is used internally to provide hooks for <CharStyle:pod-C>Data::Dumper<CharStyle:> to produce readable output and for <CharStyle:pod-C>Storable<CharStyle:> to serialize and re-construct <CharStyle:pod-C>Alter<CharStyle:>-based objects. The actual object body, in case there is any to speak of, is also accounted for. These hooks are generic and work for all <CharStyle:pod-C>Alter<CharStyle:>-based classes. Per default, they are inherited by classes that <CharStyle:pod-C>use Alter<CharStyle:>.
<pstyle:Feature Sub Section>The future of Alter
<pstyle:Feature Para>In my entirely humble opinion the Alter technique ought to revolutionize Perl OO. It reconciles the original object model <0x201C>An object is a reference ...<0x201D> with the requirements of free subclassing while keeping the additional fuzz to a minimum. Since object dumping and serialization are supported, class development with Alter isn<0x2019>t much different from the traditional approach. The resulting class can advertise itself as capable of becoming a parent class of <CharStyle:pod-I>any<CharStyle:> other class, traditional, inside-out, or itself <CharStyle:pod-C>Alter<CharStyle:> based.
<pstyle:Feature Para>The one big fly in the ointment is that <CharStyle:pod-C>Alter<CharStyle:> is an <CharStyle:pod-C>XS<CharStyle:> module on CPAN and would have to be a pre-requisite of any class that builds on it. Users without a compiler (or without the right compiler) will be unable to use any such class. It will be hard for <CharStyle:pod-C>Alter<CharStyle:> to gain the critical mass of users that makes binary ports sprout.
<pstyle:Feature Para>The inside-out technique rests on a single primitive, <CharStyle:pod-C>Scalar::Util::refaddr<CharStyle:> which is available in core Perl. That is its one big advantage.
<pstyle:Feature Para>Perl programmers have learned to live without the kind of free inheritance that inside-out and Alter have to offer. Inheritance is used internally to construct classes, but nobody even thinks, for instance, of combining two arbitrary classes from CPAN in a common subclass. One would have to be extremely lucky, or invest major work, to make that happen. If at least one of the classes is freely inheritable, there is no problem.
<pstyle:Feature Para>Combination of foreign classes happens more often through other means like a <CharStyle:pod-I>has-a<CharStyle:> relation and <CharStyle:pod-I>delegation<CharStyle:>. Just how significant the advantages of free inheritance are is hard to say because there is no considerable corpus of such classes yet to prove the point.
<pstyle:Feature Para>Finally, if I<0x2019>m not entirely wrong, there is a feeling of fatigue in the Perl community about propositions to revolutionize Perl OOP.
<pstyle:Feature Para>Nevertheless, I<0x2019>d like to project what could be done if the Alter technique became core Perl. The primitives <CharStyle:pod-C>alter<CharStyle:>, <CharStyle:pod-C>ego<CharStyle:> (and <CharStyle:pod-C>corona<CharStyle:>) could go into <CharStyle:pod-C>Scalar::Util<CharStyle:>, there<0x2019>s probably no need of a formal module. But why stop there? The use of the <CharStyle:pod-C>ego()<CharStyle:> function on object access could conceivably be made transparent by adding a particular kind of de-reference overloading to the existing <CharStyle:pod-C>overload<CharStyle:> module. It would have to kick in on <CharStyle:pod-I>every<CharStyle:> de-reference of an object and call the <CharStyle:pod-C>ego()<CharStyle:> function on the given object.
<pstyle:Feature Para>A few problems with this approach (vague idea, rather) are not solved. It is not clear how <0x201C>ego overloading<0x201D> should interact with the normal overloading of de-referencing. Also, it seems that it would be undesirable for ego overloading to be inheritable, the way normal overloading is. Unsuspecting classes that find themselves overloading all de-referencing may be in trouble if care is not taken. If the mechanism is to piggyback on the existing overload code, disabling inheritance may be a hard nut to crack if it is indeed necessary.
<pstyle:Feature Para>The intended type of object could be specified in the <CharStyle:pod-C>overload<CharStyle:> declaration, perhaps in the form
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    use overload ego =\> {}<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>and isn<0x2019>t a syntax extension always the easiest part? Then the initialization of objects could make use of the fact that the alter ego is auto-created when needed, so the <CharStyle:pod-C>alter()<CharStyle:> function would not be strictly necessary. You<0x2019>d overload your object<0x2019>s <0x201C>ego<0x201D> with the desired data type and continue to write your class (mostly) like a conventional class whose objects <CharStyle:pod-I>are<CharStyle:> that data type.
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> References	
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> About the Author	
