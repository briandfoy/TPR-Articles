<ASCII-MAC>
<Version:5><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>>
<pstyle:Feature Lead><CharStyle:pod-I>The Productive Programmer<CharStyle:> lands on the desk carrying the added weight of a huge promise: To lay bare the mechanics of why one programmer can be a hundred times as productive as another. ÊWe<0x2019>ve known and talked about this statistic for decades, but never has a book taken such square aim at the bullseye of the holy grail of developers: How to raise your game to the level of the programming masters. ÊThat<0x2019>s enough to make anyone keep turning the pages, but also demands a brutally honest assessment of how well the book delivers on its promise in return for your attention.
<pstyle:Feature Para>I started this book dearly hoping it wouldn<0x2019>t be another lesson in refactoring Java, because I want to be as productive as the masters. First, the bad news: Most of the examples in the book are in Java, with a few in Ruby, and the only mention of Perl I could find was quoting Larry Wall on the virtues of a programmer in the foreword. Now, I don<0x2019>t want to be a language bigot, and certainly nothing about this book promised it would have <CharStyle:pod-I>anything<CharStyle:> to do with Perl, but it just bugs the heck out of me when people claim that <CharStyle:pod-I>this<CharStyle:> (taken from the book) is user-friendly syntax:
<pstyle:Feature Para>Ê Ê Ê Ê@Test public void factors_for_1() { Ê Ê Ê Ê Ê Ê Ê ÊList\<Integer\> expected = new ArrayList\<Integer\>(1); Ê Ê Ê Ê Ê Ê Ê Êexpected.add(1); Ê Ê Ê Ê Ê Ê Ê ÊClassifier c = new Classifier(1); Ê Ê Ê Ê Ê Ê Ê ÊassertThat(c.getFactors(), is(expected)); Ê Ê Ê Ê}
<pstyle:Feature Para>when the Perl equivalent is:
<pstyle:Feature Para>Ê Ê Ê Êis_deeply [ get_factors(1) ], [ 1 ];
<pstyle:Feature Para>or, if the factorizer simply must be object-oriented:
<pstyle:Feature Para>Ê Ê Ê Êis_deeply [ Factorize-\>new(1)-\>get_factors ], [ 1 ];
<pstyle:Feature Para>But enough venting. ÊBefore the book gets heavily into code, it gives advice that will be dear to the hearts of many of our readers. Starting from the aphorism that <0x201C>Eye candy looks good but isn<0x2019>t nutritious,<0x201D> (I<0x2019>m sure many of you who haven<0x2019>t heard that one before will turn it into a catchphrase), the author nails his colors to the wall with exhortations to embrace the command line, shun GUIs, and prefer typing over mousing. ÊHe explores keyboard accelerators, application launchers and macro generators (he says that hotkeys have problems on Windows but I<0x2019>ve found Macro Express works in everything I use). ÊI didn<0x2019>t know that Windows even has command history searching and tab completion.
<pstyle:Feature Para>Ford is unfailingly polite in giving platforms equal time and Windows, Macintosh, and *nix users will all find help. ÊI<0x2019>ve needed a way to make true filesystem links on Windows for a while and this book was worth getting just to learn from it about a utility called Junction that does that.
<pstyle:Feature Para>These tidbits are wrapped in the contexts of accelerating your keyboard performance, reducing distractions, and automating common tasks. ÊIt then heads into the major category of Practice, which is where it waxes on various object-oriented programming philosophies.
<pstyle:Feature Para>The book has practical advice on source code analysis such as code coverage and automated duplication detection (something I do in my code review business). ÊWhen it veers back into the Java world it makes the assertion that all objects should always have valid state and therefore should never be born naked, i.e., constructors must populate the object with valid data (good luck with that), and mutating methods should be restricted so they cannot create an invalid state (like leaving a person with a missing city in their address), so that methods don<0x2019>t have to worry about the possibility of invalid state (again, good luck with that).
<pstyle:Feature Para>Here I am watching Olympic diving, where the competitors<0x2019> scores are weighted by the degree of difficulty of what they attempt. ÊAnd this book is attempting an armstand back triple somersault with a half twist, and just because it ends up over-rotating on entry doesn<0x2019>t stop it from scoring higher than a perfectly executed reverse double somersault. ÊWhich is a convoluted way of saying, this book is worth reading, especially if you use Java or Ruby. ÊIt covers numerous up-to-the-minute technologies, and does explicitly embrace the concept of polyglot programming, including examples from Groovy and Jaskell (earning a high score from the Web 2.0 judge). ÊThere<0x2019>s an unorthodox use for Ant (cleaning up files for trainings). ÊThere<0x2019>s even a thought-provoking spoiler on the mechanics of the old PacMan game.
<pstyle:Feature Para>If, however, you were expecting an exhaustive exploration of the productivity gap and blueprints for a bridge, I don<0x2019>t think this book is going to get you more than a little of the way there. ÊJon Bentley<0x2019>s <CharStyle:pod-I>Programming Pearls<CharStyle:> and Gerald Weinberg<0x2019>s <CharStyle:pod-I>The Psychology of Computer Programming<CharStyle:> have set the bar pretty high already. ÊThis book provides some contemporary embellishments of their ideas, but you still need to get those classics under your belt.
<pstyle:Feature Para>It<0x2019>s tempting to think that <CharStyle:pod-I>The Productive Programmer<CharStyle:> was written as a response to <CharStyle:pod-I>The Pragmatic Programmer<CharStyle:> (ISBN 978-0201616224), but aside from the alliterative parallels, I couldn<0x2019>t come up with any others, so I<0x2019>ll just have to leave that one to the conspiracy theorists.
<pstyle:Feature Para>Peter Scott is the author of <CharStyle:pod-I>Perl Medic<CharStyle:> and <CharStyle:pod-I>Perl Debugged<CharStyle:> and gives corporate trainings in Perl. ÊHe<0x2019>ll be teaching a full day class on dealing with legacy code at the Pittsburgh Perl Workshop this October.
