<ASCII-MAC>
<Version:5><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>>
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Perl and Undecidability 3: Perl Parsing is Undecidable	
<pstyle:Feature Section Lead>This is the last of three articles based on a formal proof of Perl<0x2019>s unparseability that I originally presented in perlmonks. This winter I retired to the edge of a frozen New England lake to work full-time on a parser generator, one that would generate a parser from any grammar describable in BNF. No such tool is in general use. I hope to create one. An alpha version is on CPAN as <CharStyle:pod-C>Parse::Marpa<CharStyle:>.
<pstyle:Feature Para>Looking for test cases, I considered Perl 5. This led me to Adam Kennedy<0x2019>s <CharStyle:pod-C>PPI<CharStyle:> documentation and his suggestion of how to prove that Perl parsing is not decidable. For some reason, it was not immediately obvious to me that Adam was right. Perhaps my optimism about parsing Perl 5 came from routinely walking on water (frozen lake, remember). In any case, to be convinced, I needed to work the proof out formally for myself.
<pstyle:Feature Para>I posted the result on perlmonks. Since the Perl unparseability proof is of practical interest rather than theoretical significance, I tried to make my writeup accessible to readers who don<0x2019>t care about math for its own sake, but who do care about things that are of practical use. The perlmonks posting attracted enough interest for me to be invited to write this series.
<pstyle:Feature Para>The first of these articles proved the Halting Theorem using Perl notation. One purpose was to explain the techniques I would need in the other two articles, but it should not be forgotten that the Halting Theorem itself is an extremely practical and useful result. Imagine for a moment that the existence of unsolvable problems was known only to experts in universities. Imagine in particular that it was not generally known that you can<0x2019>t write a program to find infinite loops in arbitrary code. A lot of time would be wasted.
<pstyle:Feature Para>The second article dealt with Rice<0x2019>s Theorem, a quick and handy rule for spotting undecidable problems. Most programmers know that there are undecidable problems, and that some of them are practical questions. Less well known is just how common undecidability is. Any non-trivial question about what a Perl script does is undecidable, and the same is true of all general-purpose programming languages.
<pstyle:Feature Sub Section>The proof by way of Rice<0x2019>s Theorem
<pstyle:Feature Para>Perl is unusual among general-purpose languages in that not just Perl<0x2019>s run phase behavior, but also its parsing is, in the general case, undecidable. The second article contained a Perl unparseability proof. The proof used Rice<0x2019>s Theorem, which had several advantages.
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>1. It was short and quick.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>2. It is closest to how the proof would look in a journal if it were a publishable result. (An academic math journal would not print this result because the referees would consider it obvious. They would also reject it because practical programming languages can have limited lifespans, and the journals want results that will be relevant and readable, decades from now.)<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>3. Using Rice<0x2019>s Theorem, the second article also proved that a wide variety of other questions about Perl were undecidable, showing that the situation with Perl parsing and the Halting Question is far from rare.<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>The disadvantage of using Rice<0x2019>s Theorem is that it is a bit of a <0x201C>black box<0x201D>. It might leave you without any feeling for why Perl is not in general parseable.
<pstyle:Feature Para>This article presents two more proofs. Each lifts the cover of the black box. The first is <0x201C>direct<0x201D>, that is, it avoids the traditional approach of reduction to the Halting Theorem. Instead it assumes the existence of a general solution to Perl parsing and uses an example Perl script to show that this assumption simply can<0x2019>t be true. The second proof in this article takes the traditional approach, showing that a general solution to Perl parsing requires a general solution to the Halting Question, which is known (and which was proved in the first article of this series) to be undecidable.
<pstyle:Feature Para>Both the proofs in this article employ a <0x201C>reduction to absurdity<0x201D> -- they assume something, and show that the assumption creates a contradiction. This constitutes a proof that the assumption must be false, and that therefore the opposite of the assumption must be true. Ordinary reasoning uses this kind of logic all the time (<0x201C>If this jerk knows so much about startups, how come he needs us to pick up the tab for lunch?<0x201D>). But for some reason, when presented in its raw form, reduction to absurdity can seem strange.
<pstyle:Feature Sub Section>How not to hit it off with a girl at a party
<pstyle:Feature Para>Once upon a time there was a beautiful ballerina. She spotted a mathematician at a party, felt an instant attraction, walked up to him, and said, <0x201C>It must be wonderful to be able to do mathematics. I could never imagine following things like proofs.<0x201D> The mathematician insisted that, since she was very intelligent, she was certainly capable of not just understanding proofs, but of appreciating the beauty some of them have.
<pstyle:Feature Para>The mathematician had memorized some lines of Edna St. Vincent Millay for just such an occasion.
<pstyle:Feature Code Para><pSpaceBefore:4.500000>                              Euclid alone
<pSpaceBefore:><pstyle:Feature Code Para> has looked on beauty bare. Fortunate they
<pstyle:Feature Code Para> Who, though once only and then but far away,
<pstyle:Feature Code Para><pSpaceAfter:4.500000> Have heard her massive sandal set on stone.
<pSpaceAfter:><pstyle:Feature Para>As he quoted these lines, the mathematician felt the blood rush to his face. The ballerina did not notice, or pretended not to. Reassured, the mathematician led the ballerina through Euclid<0x2019>s short, elegant proof that there are an infinite number of primes. (An extremely intelligent and widely read woman, the ballerina already knew that a prime number is a number divisible only by itself and 1.)
<pstyle:Feature Para>The mathematician met the ballerina<0x2019>s eyes. They were violet and registered shock. He asked her what part of the proof she didn<0x2019>t understand. She told the mathematician she understood him perfectly, thank you very much.
<pstyle:Feature Para>She pointed out to the mathematician that he had started by saying that since the primes were not infinite, there must be a fixed number of them, and that therefore one of them must be the largest. That was OK, she said.
<pstyle:Feature Para>But then he had acted as if he really believed in the largest prime. He kept pretending until there was a contradiction. That was really what he was after, the contradiction.
<pstyle:Feature Para>Once he had it, he had suddenly changed his tune. He placed the entire blame for the contradiction on the largest prime and discarded it. In fact, he had never really believed in the largest prime, and was just using it the whole time.
<pstyle:Feature Para>She told the mathematician he was a vile little man, and that she would be glad to hear nothing more of him or his proofs. As she walked out of his life forever, the mathematician gazed, mesmerized by the patterns her shoulder muscles made as they rippled across her back.
<pstyle:Feature Sub Section>A direct proof
<pstyle:Feature Para>In my proof of Perl unparseability, I will, like the unlucky mathematician, assume that something exists. Then I<0x2019>ll use it to create a Perl script as a counter-example. The counter-example will show that my assumption creates an impossible situation. Since it is impossible for the assumption to be true, the assumption must be false, and that will be my proof.
<pstyle:Feature Para>What I am going to assume exists, is a function named <CharStyle:pod-C>Acme::Halt::f_nullary()<CharStyle:>, which takes two arguments. The first argument is a string containing the name of a file, and the second is a string naming a Perl function. I assume that <CharStyle:pod-C>Acme::Halt::f_nullary()<CharStyle:> returns 1 if, in the file named in the first argument, the function named in the second argument is nullary. I assume that <CharStyle:pod-C>f_nullary()<CharStyle:> returns 0 otherwise.
<pstyle:Feature Para>In the proofs, I treat Perl as if it were equivalent to a Turing machine. Turing machines are the theoretical equivalent of general-purpose computing. Technically, Turing machines don<0x2019>t allow any extensions that produce unpredictable behavior. They could not, for example, simulate the unpredictable aspects of networking. Even the <CharStyle:pod-C>time<CharStyle:> function is strictly speaking, unpredictable from the point of view of the program, and therefore goes beyond Turing equivalence.
<pstyle:Feature Para>As a practical matter, these undecidability proofs apply just as much to full-featured Perl as they do to its Turing equivalent subset. I<0x2019>ll return to this point.
<pstyle:Feature Para>My counter-example requires <CharStyle:pod-C>f_nullary<CharStyle:> to run in the compile phase. I can be sure it will, since I<0x2019>m assuming a Turing-equivalent variant of Perl. That is, suppose Perl could determine if a function in a file was nullary, but it required a special Perl builtin available only in the run phase. Even though I can<0x2019>t use that builtin in the compile phase, I know I can simulate the special builtin. I know this because I have Turing-equivalent processing available in the compile phase.
<pstyle:Feature Para>The following counter-example Perl program shows that it is impossible for there to be a <CharStyle:pod-C>f_nullary<CharStyle:> function that behaves as described.
<pstyle:Feature Code Para><pSpaceBefore:4.500000> The code for direct.pl
<pSpaceBefore:><pstyle:Feature Code Para>
<pstyle:Feature Code Para>  1 use 5.010;
<pstyle:Feature Code Para>  2 use warnings;
<pstyle:Feature Code Para>  3 use strict;
<pstyle:Feature Code Para>  4 use Acme::Halt;
<pstyle:Feature Code Para>  5 
<pstyle:Feature Code Para>  6 sub runtime_nullary {
<pstyle:Feature Code Para>  7     my $function  = shift;
<pstyle:Feature Code Para>  8     return 0
<pstyle:Feature Code Para>  9 	if not defined (my $prototype = prototype $function);
<pstyle:Feature Code Para> 10     return $prototype eq q{};
<pstyle:Feature Code Para> 11 }
<pstyle:Feature Code Para> 12 
<pstyle:Feature Code Para> 13 BEGIN {
<pstyle:Feature Code Para> 14     *dunno =
<pstyle:Feature Code Para> 15         Acme::Halt::f_nullary( __FILE__, 'dunno' )
<pstyle:Feature Code Para> 16         ? sub   {0}
<pstyle:Feature Code Para> 17         : sub() {0};
<pstyle:Feature Code Para> 18 }
<pstyle:Feature Code Para> 19 
<pstyle:Feature Code Para> 20 print 'nullary dunno: ';
<pstyle:Feature Code Para> 21 say runtime_nullary('dunno') ? 'yes' : 'no';
<pstyle:Feature Code Para> 22 
<pstyle:Feature Code Para> 23 print 'result is ';
<pstyle:Feature Code Para><pSpaceAfter:4.500000> 24 say dunno +1;
<pSpaceAfter:><pstyle:Feature Para>Looking at direct.pl, you<0x2019>ll see it<0x2019>s ordinary Perl code, and should run as long as <CharStyle:pod-C>f_nullary<CharStyle:> actually exists. The first observation the Unkind Reader might make is that, if this code proves anything, it<0x2019>s that I don<0x2019>t know how to write a useful Perl program. Let me go back to a point I made in the first article.
<pstyle:Feature Para>The code in these articles, unlike most of the code you<0x2019>ll see in <CharStyle:pod-I>The Perl Review<CharStyle:>, is not <CharStyle:pod-B>trying<CharStyle:> to be useful. This Perl code is intended as the subject of a thought problem, an aid for thinking out an issue. It<0x2019>s like Sch<0x00f6>dinger<0x2019>s cat, locked into a box with flask of poison gas under a hammer sensitive to quantum mechanical effects. Sch<0x00f6>dinger<0x2019>s intent was to pose a thought problem, dealing with Heisenberg<0x2019>s uncertainty principle and what it means at the macro level. Sch<0x00f6>dinger was not trying to deal with the issue of stray cats.
<pstyle:Feature Para>In define.pl, as in the previous articles, I prove unparseability by giving a specific example of an ambiguous Perl parse. The example, which I owe to a perlmonks post by ikegami, is
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000> dunno + 4<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>Where <CharStyle:pod-C>dunno<CharStyle:> is a function, this can be parsed in one of two ways. If <CharStyle:pod-C>dunno<CharStyle:> is prototyped as a nullary function (one which takes no arguments), the plus sign is parsed as a binary operator. Otherwise, the plus sign is parsed as a unary operator, and <CharStyle:pod-C>+4<CharStyle:> is treated as an argument to the <CharStyle:pod-C>dunno<CharStyle:> function.
<pstyle:Feature Para>The result of the expression <CharStyle:pod-C>dunno + 4<CharStyle:> can easily be different, depending on the parse. When <CharStyle:pod-C>dunno<CharStyle:> is prototyped nullary, its return value is added to 4. Otherwise, the return value of <CharStyle:pod-C>dunno + 4<CharStyle:> is the return value of <CharStyle:pod-C>dunno<CharStyle:>, and it<0x2019>s up to <CharStyle:pod-C>dunno<CharStyle:> what is done with the <CharStyle:pod-C>+4<CharStyle:>. In my examples, <CharStyle:pod-C>dunno<CharStyle:> ignores its argument.
<pstyle:Feature Para>The file define.pl is my counter-example. If <CharStyle:pod-C>f_nullary<CharStyle:> exists as defined, the existence of define.pl leads to an impossibility. Here<0x2019>s how.
<pstyle:Feature Para>If at line 15 <CharStyle:pod-C>f_nullary<CharStyle:> examines direct.pl and returns 0, indicating that direct.pl establishes a non-nullary prototype for <CharStyle:pod-C>dunno<CharStyle:>, then in lines 14-17, direct.pl will actually set <CharStyle:pod-C>dunno<CharStyle:> up with a nullary prototype. This is a contradiction, so <CharStyle:pod-C>f_nullary<CharStyle:>, as defined, can never return 0.
<pstyle:Feature Para>What if <CharStyle:pod-C>f_nullary<CharStyle:> returns non-zero at line 15? In that case lines 14-17 will set <CharStyle:pod-C>dunno<CharStyle:> up with a nullary prototype. But a non-zero return from <CharStyle:pod-C>f_nullary<CharStyle:> at line 15 by definition means that direct.pl does not set up a nullary prototype for <CharStyle:pod-C>dunno<CharStyle:>. This is a contradiction, so <CharStyle:pod-C>f_nullary<CharStyle:>, as defined, can never return a non-zero value.
<pstyle:Feature Para>Since <CharStyle:pod-C>f_nullary<CharStyle:>, as defined, cannot return either zero or a non-zero value, it cannot exist as defined.
<pstyle:Feature Para>The problem with <CharStyle:pod-C>f_nullary<CharStyle:> is not its name. If it is renamed <CharStyle:pod-C>widget<CharStyle:> the contradictions remain. Similarly, you can play around with different return values. If you rewrite <CharStyle:pod-C>f_nullary<CharStyle:> to return 42 for a nullary function and 711 for a non-nullary, the test in lines 14-17 might no longer be an elegant ternary. But clearly, if minor details of the return values of <CharStyle:pod-C>f_nullary<CharStyle:> are changed, direct.pl can also be changed to produce the same contradiction.
<pstyle:Feature Para>The problem with <CharStyle:pod-C>f_nullary<CharStyle:> is its claim to be able to tell whether a file sets a function up with a nullary prototype or not. As long as the definition continues to make that claim, some counter-example very like direct.pl can be set up that will show that that claim is impossible.
<pstyle:Feature Sub Section>Turing equivalence
<pstyle:Feature Para>In these proofs I assume that Perl programs are Turing equivalent. In particular I assume that, given a Perl program and its history to any point, what happens after that point will be entirely predictable. This predictability must be not just from some external meta-viewpoint, but from the point of view of the program. Of course, in real life Perl has extensive capabilities which expose it to, or even try to create and exploit, unpredictability.
<pstyle:Feature Para>Perl<0x2019>s <CharStyle:pod-C>rand<CharStyle:> is an example. Technically, it is not random, but pseudo-random. From a point of view that includes the system clock, <CharStyle:pod-C>rand<CharStyle:><0x2019>s results are completely predictable. But from the point of view of the Perl script, <CharStyle:pod-C>rand<CharStyle:> is usually unpredictable enough. Similarly, even when network behavior is predictable from a viewpoint that encompasses multiple nodes and their network connections, the network will often be unpredictable from the point of view of the node running the Perl script.
<pstyle:Feature Para>Even though I assume Turing equivalence, these undecidability results apply to Perl as a whole, whether its behavior is Turing equivalent or not. That<0x2019>s because, in practice, all our modern extensions beyond the Turing model create more undecidability. None of them reduce it.
<pstyle:Feature Para>As one example, suppose I allow, as an extension to Turing equivalent Perl. the full use of <CharStyle:pod-C>rand<CharStyle:>. With <CharStyle:pod-C>rand<CharStyle:> available, I can wrapper pieces of the Perl code with <CharStyle:pod-C>if (rand(2) \> 1) { ... }<CharStyle:>. Predictable behaviors in the original Perl scripts become unpredictable behaviors in the wrappered versions.
<pstyle:Feature Para>Theoretically, extensions to Turing machines might reduce undecidability. Turing discussed the possibility of <0x201C>oracles<0x201D>. Turing<0x2019>s oracles could, whether intuitively, by exercising supernatural powers, or by some other means, accurately decide undecidable problems. But Turing doesn<0x2019>t seem to have expected anyone to invent a Turing oracle, and if anyone has, they<0x2019>re keeping it quiet.
<pstyle:Feature Para>The assumption of Turing equivalence is convenient for the proofs. But there<0x2019>s a more important motivation for sticking to Turing equivalence. Undecidability which is caused by functions which go beyond the Turing model can be avoided by using those non-Turing functions carefully or not at all. The undecidability in the proofs I present in this articles comes from Perl<0x2019>s most basic control constructs. That means the implications of undecidability are harder to avoid. Sticking to Turing equivalence makes undecidability proofs more relevant to real life, not less so.
<pstyle:Feature Sub Section>Compile phase and compile-time, run phase and run-time
<pstyle:Feature Para>As described in <CharStyle:pod-I>Programming Perl<CharStyle:>, Perl runs in two major phases. The first phase is called the <CharStyle:pod-B>compile phase<CharStyle:> and the second is called the <CharStyle:pod-B>run phase<CharStyle:>. Most (but not all) of what goes on in the compile phase is compilation. Most (but not all) of what goes on in the run phase is execution.
<pstyle:Feature Para>Code execution in the compile phase happens, for example, in <CharStyle:pod-C>BEGIN<CharStyle:> blocks. <CharStyle:pod-C>BEGIN<CharStyle:> blocks are compiled along with other code during the compile phase, but unlike the other code, <CharStyle:pod-C>BEGIN<CharStyle:> blocks are executed immediately, without waiting for the run phase. Run-phase compilation occurs, as an example, in code supplied to string <CharStyle:pod-C>eval<CharStyle:><0x2019>s.
<pstyle:Feature Para>When it<0x2019>s necessary to refer to the kind of processing that is actually begin done, as opposed to the phase, <CharStyle:pod-I>Programming Perl<CharStyle:> speaks of <CharStyle:pod-B>compile time<CharStyle:> and <CharStyle:pod-B>run time<CharStyle:>. So assignments inside a <CharStyle:pod-C>BEGIN<CharStyle:> block take place in the <CharStyle:pod-I>compile phase<CharStyle:> but at <CharStyle:pod-I>run time<CharStyle:>. Inlining of constant subroutines defined in a string <CharStyle:pod-C>eval<CharStyle:> takes place in the <CharStyle:pod-I>run phase<CharStyle:>, but at <CharStyle:pod-I>compile time<CharStyle:>.
<pstyle:Feature Para>The distinction between <0x201C>time<0x201D> and <0x201C>phase<0x201D> is not always made clearly. The <CharStyle:pod-C>perlmod<CharStyle:> man page uses the terms compile-time and run-time in places where <CharStyle:pod-I>Programming Perl<CharStyle:> would insist that the correct terms are <0x201C>compile phase<0x201D> and <0x201C>run phase<0x201D>. As a result, <CharStyle:pod-C>perlmod<CharStyle:><0x2019>s explanations of what happens when can be hard to follow.
<pstyle:Feature Sub Section>Doesn<0x2019>t <CharStyle:pod-C>runtime_nullary<CharStyle:> show that the proofs are wrong?
<pstyle:Feature Para>In direct.pl, I included a routine to test the results: <CharStyle:pod-C>runtime_nullary()<CharStyle:>. It returns 1 if its argument string is the name of a nullary function, and 0 otherwise. <CharStyle:pod-C>runtime_nullary()<CharStyle:> really exists. I give the code -- it<0x2019>s all basic Perl and Perl builtins, used as documented. And I<0x2019>ve tested it. Doesn<0x2019>t the very real existence of <CharStyle:pod-C>runtime_nullary()<CharStyle:> mean that it is decidable whether a function has a nullary prototype? And doesn<0x2019>t that mean there must be something wrong with each of my three proofs?
<pstyle:Feature Para>Specifically, even if you have a Perl program not parseable in the compile phase, why can<0x2019>t you do the following?
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Add logic to list all functions with nullary prototypes in the Perl program. Put this logic where it will be executed at the end of the run phase. (In so doing, you must not alter the parse of the original code. With caution that should be possible.)<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Next, run the Perl program through the compile phase and the run phase, including through the new logic that produces the nullary prototype listing.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Take the nullary prototype information produced by this first run. Feed it into a second pass over the Perl script which uses the nullary prototype information to decide the parse.<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>This two-pass method is kludgy, but it is similar to the way some text processors create indexes and cross-references. At least one text processor which works this way sees widespread, if not complaint-free, use.
<pstyle:Head3Style>First, a weird quibble
<pstyle:Feature Para>The first problem I<0x2019>ll point out with the two-pass method is, I<0x2019>ll admit, a bit of a quibble. Perl allows you to change the prototype as you proceed through the compile phase.
<pstyle:Feature Para>In particular, there can be multiple <CharStyle:pod-C>BEGIN<CharStyle:> blocks, each setting a different prototype for the same function. The setting of prototypes can even be conditional. Perl tells you when you redefine subroutines, and squawks even louder when you change the prototype, but both these messages are warnings and both can be turned off.
<pstyle:Feature Para><CharStyle:pod-C>runtime_nullary<CharStyle:> will only report the most recent prototype. This may not have been the one which was in effect when most of the Perl code was parsed.
<pstyle:Feature Para>At this point, you may say, <0x201C>That<0x2019>s possible, but it<0x2019>s just such a weird corner case, let<0x2019>s ignore it.<0x201D> It is pretty weird, actually. Fine. Let<0x2019>s ignore it.
<pstyle:Head3Style>Second, run phase prototype changes don<0x2019>t count
<pstyle:Feature Para>There<0x2019>s a more serious obstacle to the two pass method. Function prototypes set up after the compile phase aren<0x2019>t used in parsing. They don<0x2019>t count.
<pstyle:Feature Para>To be precise, they don<0x2019>t count in most cases. In those places where compile-time happens during the run phase, it uses any function prototypes that were set up earlier in the run phase.
<pstyle:Feature Para>But for most run phase processing, the code has already been compiled when the run phase begins. Changes made to function prototypes do not affect the parse, and information about run phase changes to function prototypes is useless.
<pstyle:Head3Style>Third, there<0x2019>s the Halting Problem
<pstyle:Feature Para>The most basic problem with using <CharStyle:pod-C>runtime_nullary<CharStyle:> to assist in parsing, is that there is no way to ensure, in general, that <CharStyle:pod-C>runtime_nullary<CharStyle:> will ever be called. The Perl script might be an infinite loop.
<pstyle:Feature Para>In this direct proof, we didn<0x2019>t reduce Perl parsing to the Halting Question, but the issue of whether or not code is an infinite loop never goes away. And the Halting Question lies behind a question that is commoner in practice: For some length of time <CharStyle:pod-B>N<CharStyle:>, where <CharStyle:pod-B>N<CharStyle:> is too long for a direct test to be practical, does some arbitrary code take time <CharStyle:pod-B>N<CharStyle:> or longer to run? Proving undecidability by reduction to the Halting Question tackles the issue of infinite loops directly, rather than trying to deal with them as a side issue.
<pstyle:Feature Sub Section>A traditional proof
<pstyle:Feature Para>Here is the Perl unparseability proof in the traditional form of a reduction to the Halting Question. First, I will prove Kennedy<0x2019>s Lemma:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    If you can parse Perl, you can answer the Halting Question<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>I call this Kennedy<0x2019>s Lemma, because I first saw it stated in Adam Kennedy<0x2019>s <CharStyle:pod-C>PPI<CharStyle:> documentation.
<pstyle:Feature Para>The proof of Kennedy<0x2019>s Lemma is another reduction to absurdity. Once again I assume I have a routine that returns 1 if a subroutine has a nullary prototype, and 0 otherwise. This time I assume it is named <CharStyle:pod-C>s_nullary<CharStyle:>, that it analyzes a string of Perl code that is its first argument, and that the name of the subroutine is its second argument.
<pstyle:Feature Para>Perl is Turing-complete. I will also assume that some helpful and theoretically-oriented chap has written a subroutine named <CharStyle:pod-C>run_turing_machine<CharStyle:> which takes a Turing machine representation as its first argument, and input for that Turing machine as its second argument.
<pstyle:Feature Para>On these two assumptions, I can write the following Perl subroutine, which solves the Halting Question for an arbitrary Turing machine with arbitrary input.
<pstyle:Feature Code Para><pSpaceBefore:4.500000>  1 sub halts {
<pSpaceBefore:><pstyle:Feature Code Para>  2     my $machine                = shift;
<pstyle:Feature Code Para>  3     my $input                  = shift;
<pstyle:Feature Code Para>  4     my $code_string_to_analyze = qq{
<pstyle:Feature Code Para>  5         BEGIN {
<pstyle:Feature Code Para>  6             run_turing_machine("\\Q$machine\\E", "\\Q$input\\E");
<pstyle:Feature Code Para>  7             sub whatever() {};
<pstyle:Feature Code Para>  8         }
<pstyle:Feature Code Para>  9     };
<pstyle:Feature Code Para> 10     s_nullary( $code_string_to_analyze, 'whatever' );
<pstyle:Feature Code Para><pSpaceAfter:4.500000> 11 }
<pSpaceAfter:><pstyle:Feature Para>Specifically, <CharStyle:pod-C>s_nullary<CharStyle:> in line 10, in order to figure out whether <CharStyle:pod-C>whatever<CharStyle:> is given a nullary prototype, has to figure out whether line 7 is ever executed. To do this <CharStyle:pod-C>s_nullary<CharStyle:> must somehow figure out whether line 6 will ever finish. Line 6 runs a arbitrary Turing Machine with arbitrary input, and so in order to know the prototype of <CharStyle:pod-C>whatever<CharStyle:>, <CharStyle:pod-C>run_turing_machine<CharStyle:> must be able to solve the the Halting Question. This proves Kennedy<0x2019>s Lemma.
<pstyle:Feature Para>With Kennedy<0x2019>s Lemma proved, a simple reduction to absurdity proves that Perl is unparseable. By Kennedy<0x2019>s Lemma, if you can parse Perl, you can solve the Halting Question. But you can<0x2019>t solve the Halting Question. Therefore you can<0x2019>t parse Perl. QED.
<pstyle:Feature Sub Section>Conclusion
<pstyle:Feature Para>These articles have shown that, in general, Perl parses are not decidable during Perl<0x2019>s compile phase, and that carrying the problem over into the run phase will not help. Perl cannot always parse Perl. And, however you define static and dynamic, Perl is not, in general, either statically or dynamically parseable.
<pstyle:Feature Para>Perl<0x2019>s unparseability comes from one of its basic, deepest properties -- it gives Turing-complete power to the programmer at compile time. With Turing-completeness comes undecidability.
<pstyle:Feature Para>Perl unparseability is not a bug or a misfeature. It<0x2019>s an inseparable aspect of a feature -- Perl<0x2019>s full power is available when setting up its own compilation environment. This is a valuable feature, purchased mainly with the depreciated currency of theoretical purity.
<pstyle:Feature Sub Section>References
<pstyle:Feature Para><CharStyle:pod-I>Programming Perl, 3rd Edition<CharStyle:> by Larry Wall, Jon Orwant, and Tom Christiansen discusses Perl compilation in Chapter 18. It sets out a distinction between compile/run time and compile/run phase.
<pstyle:Feature Para>The <CharStyle:pod-I>perlmod<CharStyle:> man page attempts to cover the same ground.
<pstyle:Feature Para>Randal Schwartz<0x2019>s perlmonks node <0x201C>On Parsing Perl<0x201D>, was a important development in this discussion: <CharStyle:pod-I>http://www.perlmonks.org/?node_id=44722<CharStyle:>
<pstyle:Feature Para>ikegami<0x2019>s elegant example of parsing ambiguity in Perl, from Perlmonks: <CharStyle:pod-I>http://perlmonks.org/?node_id=688260<CharStyle:>
<pstyle:Feature Para><0x201C>Perl Cannot Be Parsed: A Formal Proof<0x201D>, my original Perlmonks post on Perl<0x2019>s unparseability: <CharStyle:pod-I>http://www.perlmonks.org/?node_id=663393<CharStyle:>
<pstyle:Feature Para>My general BNF parser, currently in alpha: <CharStyle:pod-I>http://search.cpan.org/dist/Parse-Marpa<CharStyle:>
<pstyle:Feature Para>Adam Kennedy<0x2019>s PPI module: <CharStyle:pod-I>http://search.cpan.org/dist/PPI<CharStyle:>
<pstyle:Feature Para>Edna St. Vincent Millay, <0x201C>Euclid Alone Has Looked on Beauty Bare<0x201D>.
<pstyle:Feature Para>Euclid<0x2019>s Theorem (the proof that there are an infinite number of primes) is given on Wikipedia<0x2019>s <0x201C>Prime numbers<0x201D> page: <CharStyle:pod-I>http://en.wikipedia.org/wiki/Prime_numbers#There_are_infinitely_many_prime_numbers<CharStyle:>. It also has its own page on Wikipedia: <CharStyle:pod-I>http://en.wikipedia.org/wiki/Euclid%27s_theorem<CharStyle:>.
