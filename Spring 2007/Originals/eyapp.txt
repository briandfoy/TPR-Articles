<ASCII-MAC><Version:4><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>><ParaStyle:Normal><CharStyle:Normal><CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal> (Extended yapp) is a collection of modules that extends Francois Desarmenien's <CharStyle:pod-C>Parse::Yapp<CharStyle:Normal>. Eyapp extends the yacc/yapp syntax to use named attributes, Extended Bacchus-Noir Form (EBNF)-like expressions, modifiable default actions, automatic syntax tree building, semi-automatic abstract syntax tree building, translation schemes, tree regular expressions, tree transformations, scope analysis support, and directed acyclic graphs. I'll show the basics of compiler construction and <CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal> by building a translator from infix expressions to Parrot Intermediate Representation (PIR).<ParaStyle:article subhead><CharStyle:Subhead>Parsing<ParaStyle:Normal><CharStyle:Normal>Text analysis is Perl's major strength. Along with regular expression, modules such as <CharStyle:pod-C>Parse::RecDescent<CharStyle:Normal> and <CharStyle:pod-C>Parse::Yapp<CharStyle:Normal> make it easy to parse and transform text. However, Perl 5 doesn't have built-in tools to handle XML, HTML, symbolic mathematics I need for the subsequent stages of text processing. <ParaStyle:Normal><CharStyle:Normal>This article introduces the basics of translator construction with <CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal> by compiling infix expressions into Parrot Intermediate Representation (PIR). The input to my program is a semicolon-separated list of infix expressions:<ParaStyle:perl codeblock><CharStyle:pod-C>b = 5;<ParaStyle:perl codeblock><CharStyle:pod-C>a = b+2;<ParaStyle:perl codeblock><CharStyle:pod-C>a = 2*(a+b)*(2-4/2); # is zero<ParaStyle:perl codeblock><CharStyle:pod-C>print a;<ParaStyle:perl codeblock><CharStyle:pod-C>d = (a = a+1)*4-b;<ParaStyle:perl codeblock><CharStyle:pod-C>c = a*b+d;<ParaStyle:perl codeblock><CharStyle:pod-C>print c;<ParaStyle:perl codeblock><CharStyle:pod-C>print d<ParaStyle:Normal><CharStyle:Normal>The output is an equivalent PIR: <ParaStyle:perl codeblock><CharStyle:pod-C>.sub 'main' :main<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> .local num a, b, c, d<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> b = 5<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> a = b + 2<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> a = 0 # expression at line 3 <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print "a = "     # above was<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print a    # reduced to zero<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print "\\n" # at compile time<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> a = a + 1<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $N5 = a * 4<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> d = $N5 - b<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $N7 = a * b<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> c = $N7 + d<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print "c = "<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print c<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print "\\n"<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print "d = "<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print d<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> print "\\n"<ParaStyle:perl codeblock><CharStyle:pod-C>.end<cLeading:13.000000><cFont:Arial><cLeading:><cFont:><ParaStyle:article subhead><CharStyle:Subhead>Transformation Stages<ParaStyle:Normal><CharStyle:Normal>The code below displays the stages of the translator: <ParaStyle:list><CharStyle:Normal><0x2022> lexical and syntax analysis<ParaStyle:list><CharStyle:Normal><0x2022> tree transformations and decorations<ParaStyle:list><CharStyle:Normal><0x2022> address assignments<ParaStyle:list><CharStyle:Normal><0x2022> code generation<ParaStyle:list><CharStyle:Normal><0x2022> peephole optimization<ParaStyle:Normal><CharStyle:Normal>The simplicity of my example input (no types and no control structures) permits me to skip context handling, also  known as semantic analysis. Context handling includes type checking and live analysis. I'll explain more about each phase as I develop my example. Here are the major steps represented as code, which I call <CharStyle:pod-C>eyapp<CharStyle:Normal>:<ParaStyle:perl codeblock><CharStyle:pod-C>my $parser = Infix-\>new();<ParaStyle:perl codeblock><CharStyle:pod-C># Set input <ParaStyle:perl codeblock><CharStyle:pod-C>$parser-\>YYData-\>{INPUT} <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> = slurp_file($filename, 'inf');<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C># Lexical and syntax analysis<ParaStyle:perl codeblock><CharStyle:pod-C>my $t = $parser-\>YYParse(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>yylex   =\> \\&Infix::Lex, <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>yyerror =\> \\&Infix::Err);<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C># Tree transformations<ParaStyle:perl codeblock><CharStyle:pod-C>$t-\>s(our @algebra);<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C># Address assignment<ParaStyle:perl codeblock><CharStyle:pod-C>our $reg_assign;<ParaStyle:perl codeblock><CharStyle:pod-C>$reg_assign-\>s($t);<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C># Code generation<ParaStyle:perl codeblock><CharStyle:pod-C>$t-\>bud(our @translation);<ParaStyle:perl codeblock><CharStyle:pod-C>my $dec = build_dec();<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C>peephole_optimization($t-\>{trans});<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C>output_code(\\$t-\>{trans}, \\$dec);<ParaStyle:Normal><CharStyle:Normal>The compiler uses the parser for infix expressions that was generated from the Eyapp grammar  <CharStyle:pod-C>Infix.eyp<CharStyle:Normal> (which I'll develop later in the artile) using the command:<ParaStyle:perl codeblock><CharStyle:pod-C>$ eyapp Infix.eyp<ParaStyle:perl codeblock><CharStyle:pod-C>$ ls -tr | tail -1<ParaStyle:perl codeblock><CharStyle:pod-C>Infix.pm<ParaStyle:Normal><CharStyle:Normal>It also uses the module containing different families of tree transformations that are described in the <CharStyle:pod-C>I2PIR.trg<CharStyle:Normal> file (explained later):<ParaStyle:perl codeblock><CharStyle:pod-C>$ treereg -m main I2PIR.trg<ParaStyle:perl codeblock><CharStyle:pod-C>$ ls -tr | tail -1<ParaStyle:perl codeblock><CharStyle:pod-C>I2PIR.pm<ParaStyle:perl codeblock><CharStyle:pod-C>$ head -1 I2PIR.pm<ParaStyle:perl codeblock><CharStyle:pod-C>package main;<ParaStyle:Normal><CharStyle:Normal>The option <CharStyle:pod-C>-m main<CharStyle:Normal> tells <CharStyle:pod-C>treereg<CharStyle:Normal> to place the transformations inside the <CharStyle:pod-C>main<CharStyle:Normal> namespace.<ParaStyle:article subhead><CharStyle:Subhead>Lexical Analysis<ParaStyle:Normal><CharStyle:Normal>Lexical analysis decomposes the input stream in a sequence of lexical units called \\emph{tokens}. Associated with each token is its \\emph{attribute} which carries the corresponding information. In the code example below the attribute associated with token <CharStyle:pod-C>NUM<CharStyle:Normal> is its numerical value and the attribute associated with token <CharStyle:pod-C>VAR<CharStyle:Normal> is the actual string. Each time the parser encounters a new token, the lexer returns the couple <CharStyle:pod-C>(token, attribute)<CharStyle:Normal> that matched. <ParaStyle:perl codeblock><CharStyle:pod-C>sub Lex {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> my($parser)=shift; <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> for ($parser-\>YYData-\>{INPUT}) { <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   m{\\G[ \\t]*}gc;<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   m{\\G\\n}gc                      <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     and $lineno++;<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   m{\\G([0-9]+(?:\\.[0-9]+)?)}gc   <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     and return('NUM',$1);<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   m{\\Gprint}gc                   <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     and return('PRINT', 'PRINT');<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   m{\\G([A-Za-z][A-Za-z0-9_]*)}gc <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     and return('VAR',$1);<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   m{\\G(.)}gc                     <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     and return($1,$1);<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   return('',undef); # End of input<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> }<ParaStyle:perl codeblock><CharStyle:pod-C>}<ParaStyle:Normal><CharStyle:Normal>Some tokens, such as <CharStyle:pod-C><cStrokeTint:7.000000>PRINT<cStrokeTint:><CharStyle:Normal>, do not carry any special information. In such cases, just to keep the protocol simple, the lexer returns the couple <CharStyle:pod-C>(token, token)<CharStyle:Normal>. In Eyapp terminology, these tokens are called <CharStyle:pod-I>syntactic tokens<CharStyle:Normal>. S<CharStyle:pod-I>emantic tokens<CharStyle:Normal> are those tokens, such as <CharStyle:pod-C>VAR<CharStyle:Normal> or <CharStyle:pod-C>NUM<CharStyle:Normal>, whose attributes have useful information. When the end of input is reached the lexer returns the couple <CharStyle:pod-C>('', undef)<CharStyle:Normal>.<ParaStyle:Normal><CharStyle:Normal><cTypeface:Italic><cHorizontalScale:1.100000><cFont:Arial Black>Syntatic Analysis<cTypeface:><cHorizontalScale:><cFont:><ParaStyle:Normal><CharStyle:Normal>The code below shows the body of the grammar, which I stored in the file <CharStyle:pod-C>Infix.eyp<CharStyle:Normal> and used in the previous section. Eyapp syntax very much resembles the syntax of <CharStyle:pod-C>yacc<CharStyle:Normal>. An Eyapp program has three parts: the head, body and tail. Each part is separated from the former by the symbol <CharStyle:pod-C>%%<CharStyle:Normal>. The head section contains declarations, code support and directives. The grammar rules describing the language  and the semantic actions that indicate how evaluate the attributes associated with the symbols go in the body section. The tail section includes Perl code that supports the semantic actions. Commonly the lexical analyzer and error diagnostic subroutines go there.<ParaStyle:perl codeblock><CharStyle:pod-C>%right  '='        # Head section<ParaStyle:perl codeblock><CharStyle:pod-C>%left   '-' '+'<ParaStyle:perl codeblock><CharStyle:pod-C>%left   '*' '/'<ParaStyle:perl codeblock><CharStyle:pod-C>%left   NEG<ParaStyle:perl codeblock><CharStyle:pod-C>%tree <ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C>%%<ParaStyle:perl codeblock><CharStyle:pod-C>line:             # Body section<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> sts \<%name EXPS + ';'\><ParaStyle:perl codeblock><CharStyle:pod-C>;<ParaStyle:perl codeblock><CharStyle:pod-C>sts:<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   %name PRINT<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   PRINT leftvalue<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | exp <ParaStyle:perl codeblock><CharStyle:pod-C>;<ParaStyle:perl codeblock><CharStyle:pod-C>exp:<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   %name NUM    NUM<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | %name VAR    VAR<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | %name ASSIGN leftvalue '=' exp<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | %name PLUS   exp '+' exp<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | %name MINUS  exp '-' exp<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | %name TIMES  exp '*' exp<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | %name DIV    exp '/' exp<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> | %name NEG<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>         '-' exp %prec NEG<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> |            '(' exp ')'<ParaStyle:perl codeblock><CharStyle:pod-C>;<ParaStyle:perl codeblock><CharStyle:pod-C>leftvalue : %name VAR VAR<ParaStyle:perl codeblock><CharStyle:pod-C>;<ParaStyle:perl codeblock><CharStyle:pod-C>%% <ParaStyle:perl codeblock><CharStyle:pod-C>...               # tail section<ParaStyle:Normal><CharStyle:Normal>Eyapp grammars can be ambiguous. By associating priorities with tokens the programmer can tell Eyapp what syntax tree to build in case of a conflict. The declarations <CharStyle:pod-C>%nonassoc<CharStyle:Normal>, <CharStyle:pod-C>%left<CharStyle:Normal> and <CharStyle:pod-C>%right<CharStyle:Normal> declare and associate a {\\it priority} with the tokens that follow them. Tokens declared in the same line have the same precedence. Tokens declared in lines below have more precedence than those declared above. Thus, in the example we are saying that <CharStyle:pod-C>'+'<CharStyle:Normal> and <CharStyle:pod-C>'-'<CharStyle:Normal> have the same precedence but higher than <CharStyle:pod-C>'='<CharStyle:Normal>. The final effect of <CharStyle:pod-C>'-'<CharStyle:Normal> having greater precedence than <CharStyle:pod-C>'='<CharStyle:Normal> is that an expression like <CharStyle:pod-C>a=4-5<CharStyle:Normal> is interpreted as <CharStyle:pod-C>a=(4-5)<CharStyle:Normal> and not as <CharStyle:pod-C>(a=4)-5<CharStyle:Normal>.  The use of <CharStyle:pod-C>%left<CharStyle:Normal> applied to <CharStyle:pod-C>'-'<CharStyle:Normal> indicates that - in case of ambiguity and a match between precedences - the parser must build the tree corresponding to a left parenthesization. Thus, <CharStyle:pod-C>4-5-9<CharStyle:Normal> is interpreted as  <CharStyle:pod-C>(4-5)-9<CharStyle:Normal>.<ParaStyle:Normal><CharStyle:Normal><CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal> facilitates the construction of abstract syntax trees (AST) through the <CharStyle:pod-C>%tree<CharStyle:Normal> directive. Nodes in the AST are blessed in the production <CharStyle:pod-C>name<CharStyle:Normal>. A <CharStyle:pod-I>right hand side<CharStyle:Normal> (rhs) can be {\\it named} using the <CharStyle:pod-C>%name IDENTIFIER<CharStyle:Normal> directive. For each <CharStyle:pod-I>rhs name<CharStyle:Normal> a class/package with name <CharStyle:pod-C>IDENTIFIER<CharStyle:Normal> is created.<ParaStyle:Normal><CharStyle:Normal>Symbolic tokens (like <CharStyle:pod-C>NUM<CharStyle:Normal> <CharStyle:pod-C>PRINT<CharStyle:Normal> or <CharStyle:pod-C>VAR<CharStyle:Normal>) are considered by default <CharStyle:pod-I>semantic tokens<CharStyle:Normal>. String literals (like <CharStyle:pod-C>'+'<CharStyle:Normal>, <CharStyle:pod-C>'/'<CharStyle:Normal>, etc.) are - unless explictly declared using the <CharStyle:pod-C>semantic token<CharStyle:Normal> directive - considered <CharStyle:pod-I>syntactic tokens<CharStyle:Normal>. When building the AST syntactic tokens do not yield new nodes. Semantic tokens however have their own. Thus when feed with input <CharStyle:pod-C>b=2*a<CharStyle:Normal> the generated parser produces the following AST\\footnote{The information between brackets shows the attribute for {\\tt TERMINAL} nodes}:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> ASSIGN(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   VAR(TERMINAL[b]),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   TIMES(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     NUM(TERMINAL[2]),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     VAR(TERMINAL[a]))<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> )<ParaStyle:perl codeblock><CharStyle:pod-C>)<ParaStyle:Normal><CharStyle:Normal>Nodes of the AST are hashes that can be <CharStyle:pod-I>decorated<CharStyle:Normal> with new keys/attributes. The only reserved field is <CharStyle:pod-C>children<CharStyle:Normal> which is a reference to the array of children. Nodes named <CharStyle:pod-C>TERMINAL<CharStyle:Normal> are built from the tokens provided by the lexical analyzer. The couple <CharStyle:pod-C>($token, $attribute)<CharStyle:Normal> returned by the lexical analyzer is stored under the keys <CharStyle:pod-C>token<CharStyle:Normal> and <CharStyle:pod-C>attr<CharStyle:Normal>. <CharStyle:pod-C>TERMINAL<CharStyle:Normal> nodes also have the attribute <CharStyle:pod-C>children<CharStyle:Normal> which is set to an anonymous empty list. Observe the absence of <CharStyle:pod-C>TERMINAL<CharStyle:Normal> nodes corresponding to tokens <CharStyle:pod-C>'='<CharStyle:Normal> and <CharStyle:pod-C>'*'<CharStyle:Normal>. If we change the status of <CharStyle:pod-C>'*'<CharStyle:Normal> and <CharStyle:pod-C>'='<CharStyle:Normal> to <CharStyle:pod-C>semantic<CharStyle:Normal> using the <CharStyle:pod-C>%semantic token<CharStyle:Normal> directive:<ParaStyle:perl codeblock><CharStyle:pod-C>1   %semantic token '*' '='<ParaStyle:perl codeblock><CharStyle:pod-C>2   %right  '='<ParaStyle:perl codeblock><CharStyle:pod-C>3   ....  etc.<ParaStyle:Normal><CharStyle:Normal>we get a - concrete - syntax tree:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> ASSIGN(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   VAR(TERMINAL[b]),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   TERMINAL[=],<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   TIMES(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     NUM(TERMINAL[2]),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     TERMINAL[*],<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     VAR(TERMINAL[a])<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   ) # TIMES<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> ) # ASSIGN<ParaStyle:perl codeblock><CharStyle:pod-C>)<ParaStyle:Normal><CharStyle:Normal>Let us now consider the input <CharStyle:pod-C>2*(a+1)<CharStyle:Normal>. The parser yields the tree:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> TIMES(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   NUM(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>    TERMINAL[2]),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>    exp_14(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>      PLUS(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>        VAR(TERMINAL[a]),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>        NUM(TERMINAL[1]))<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>      ) # PLUS<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> ) # TIMES<ParaStyle:perl codeblock><CharStyle:pod-C>)<cLeading:13.000000><cFont:Arial><cLeading:><cFont:><ParaStyle:Normal><CharStyle:Normal>Two features are noticeable: the parenthesis rule <CharStyle:pod-C>exp:<CharStyle:Normal> <CharStyle:pod-C>'(' exp ')'<CharStyle:Normal> had no name and got automatically one: <CharStyle:pod-C>exp_14<CharStyle:Normal>. The <CharStyle:pod-I>name of a rhs<CharStyle:Normal> by default results from concatenating the left hand side of the rule with the ordinal number of the rule\\footnote{As it appears in the {\\tt .output} file. The {\\tt .output} file can be generated using the {\\tt -v} option of {\\tt eyapp}}. The second is that node <CharStyle:pod-C>exp_14<CharStyle:Normal> is useless and can be suppressed.<ParaStyle:Normal><CharStyle:Normal>The <CharStyle:pod-C>%tree<CharStyle:Normal> directive can be accompanied of the <CharStyle:pod-C>%bypass<CharStyle:Normal> clause.  A <CharStyle:pod-C>%tree bypass<CharStyle:Normal> produces an automatic <CharStyle:pod-I>bypass<CharStyle:Normal> of any node with only one child at <CharStyle:pod-I>tree-construction-time<CharStyle:Normal>. A <CharStyle:pod-I>bypass operation<CharStyle:Normal> consists in <CharStyle:pod-I>returning the only child of the node being visited to the father of the node and re-typing (re-blessing) the node in the name of the production<CharStyle:Normal>\\footnote{If the production has an explicit name. Otherwise there is no re-blessing}.<ParaStyle:Normal><CharStyle:Normal>Changing the line <CharStyle:pod-C>%tree<CharStyle:Normal> by <CharStyle:pod-C>%tree bypass<CharStyle:Normal> in file <CharStyle:pod-C>Infix.eyp<CharStyle:Normal> we get a more suitable AST for input <CharStyle:pod-C>2*(a+1)<CharStyle:Normal>:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(TIMES(NUM[2],PLUS(VAR[a],NUM[1])))<ParaStyle:Normal><CharStyle:Normal>A consequence of the global scope application of <CharStyle:pod-C>%tree bypass<CharStyle:Normal> is that undesired bypasses may occur. Consider the tree rendered for input <CharStyle:pod-C>-a*2<CharStyle:Normal>:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(TIMES(NEG,NUM))<ParaStyle:Normal><CharStyle:Normal>What happened? The bypass is applied to the rhs <CharStyle:pod-C>'-' exp<CharStyle:Normal>.  Though the rhs has two symbols, token <CharStyle:pod-C>'-'<CharStyle:Normal> is a syntactic token and at <CharStyle:pod-I>tree-construction-time<CharStyle:Normal> only <CharStyle:pod-C>exp<CharStyle:Normal> is left. The <CharStyle:pod-I>bypass<CharStyle:Normal> operation applies when building this node. This undesired <CharStyle:pod-I>bypass<CharStyle:Normal> can be avoided applying the <CharStyle:pod-C>no bypass<CharStyle:Normal> directive to the production:<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>exp : %no bypass NEG<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>      '-' exp %prec NEG<ParaStyle:Normal><CharStyle:Normal>Now the AST for <CharStyle:pod-C>-a*2<CharStyle:Normal> is:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(TIMES(NEG(VAR),NUM))<cLeading:13.000000><cFont:Arial><cLeading:><cFont:><ParaStyle:Normal><CharStyle:Normal>Eyapp provides operators <CharStyle:pod-C>+<CharStyle:Normal>, <CharStyle:pod-C>*<CharStyle:Normal> and <CharStyle:pod-C>?<CharStyle:Normal> for the creation of lists and optionals as in:<ParaStyle:perl codeblock><CharStyle:pod-C>line: sts \<EXPS + ';'\><ParaStyle:Normal><CharStyle:Normal>which states that a line is made of a non empty list of <CharStyle:pod-C>EXPS<CharStyle:Normal> separated by semicolons. By default the class name for such list is <CharStyle:pod-C>_PLUS_LIST<CharStyle:Normal>. The <CharStyle:pod-C>%name<CharStyle:Normal> directive can be used to modify the default name:<ParaStyle:perl codeblock><CharStyle:pod-C>line: sts \<%name EXPS + ';'\><cLeading:13.000000><cFont:Arial><cLeading:><cFont:><ParaStyle:Normal><CharStyle:Normal>Explicit actions can be specified by the programmer. They are managed as anonymous subroutines that receive as arguments the attributes of the symbols in the rule and are executed each time a <CharStyle:pod-I>reduction<CharStyle:Normal> by that rule occurs. When running under the <CharStyle:pod-C>%tree<CharStyle:Normal> directive this provides a mechanism to influence the shape of the AST. Observe however that the grammar in the example is \\underline{clean} of actions: <CharStyle:pod-I>Parse::Eyapp allowed us to produce a suitable AST without writing any explicit actions<CharStyle:Normal>.<ParaStyle:article subhead><CharStyle:Subhead>Tree Transformations<ParaStyle:Normal><CharStyle:Normal>Once we have the AST we can transform it using the <CharStyle:pod-I>Treeregexp<CharStyle:Normal> language. The code below (in file <CharStyle:pod-C>I2PIR.trg<CharStyle:Normal>) shows a set of algebraic tree transformations whose goal is to produce machine independent optimizations.<ParaStyle:perl codeblock><CharStyle:pod-C>{ #  Example of support code<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> use List::Util qw(reduce);<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> my %Op = (PLUS=\>'+', MINUS =\> '-',<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>           TIMES=\>'*', DIV =\> '/');<ParaStyle:perl codeblock><CharStyle:pod-C>}<ParaStyle:perl codeblock><CharStyle:pod-C>algebra = fold wxz zxw neg;<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C>fold: /TIMES|PLUS|DIV|MINUS/:b(NUM, NUM)<ParaStyle:perl codeblock><CharStyle:pod-C>=\> {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> my $op = $Op{ref($b)};<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $NUM[0]-\>{attr} = eval<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> "$NUM[0]-\>{attr} $op $NUM[1]-\>{attr}";<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $_[0] = $NUM[0];<ParaStyle:perl codeblock><CharStyle:pod-C>}<ParaStyle:perl codeblock><CharStyle:pod-C>zxw: TIMES(NUM, .) and {$NUM-\>{attr}==0}<ParaStyle:perl codeblock><CharStyle:pod-C>=\> { $_[0] = $NUM }<ParaStyle:perl codeblock><CharStyle:pod-C>wxz: TIMES(., NUM) and {$NUM-\>{attr}==0}<ParaStyle:perl codeblock><CharStyle:pod-C>=\> { $_[0] = $NUM }<ParaStyle:perl codeblock><CharStyle:pod-C>neg: NEG(NUM)<ParaStyle:perl codeblock><CharStyle:pod-C>=\> { $NUM-\>{attr} = -$NUM-\>{attr};<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>    $_[0] = $NUM }<ParaStyle:Normal><CharStyle:Normal>A Treeregexp programs is made of <CharStyle:pod-I>treeregexp<CharStyle:Normal> rules that describe what subtrees match and how transform them:<ParaStyle:perl codeblock><CharStyle:pod-C>wxz: TIMES(., NUM) and {$NUM-\>{attr}==0}<ParaStyle:perl codeblock><CharStyle:pod-C>=\> { $_[0] = $NUM }<ParaStyle:Normal><CharStyle:Normal>A rule has a <CharStyle:pod-I>name<CharStyle:Normal> (<CharStyle:pod-C>wxz<CharStyle:Normal> in the example), a <CharStyle:pod-I>term<CharStyle:Normal> describing the shape of the subtree to match <CharStyle:pod-C>"TIMES(., NUM)"<CharStyle:Normal> and two optional fields: a <CharStyle:pod-I>semantic condition<CharStyle:Normal> expliciting the attribute constraints (the code after the reserved word <CharStyle:pod-C>and<CharStyle:Normal>) and some <CharStyle:pod-I>transformation code<CharStyle:Normal> that tells how to modify the subtree (the code after the big arrow <CharStyle:pod-C>=\><CharStyle:Normal>). Each rule is translated into a subroutine \\footnote{The sub must be accessed through a proxy <CharStyle:pod-C>Parse::Eyapp::YATW<CharStyle:Normal> object. YATW stands for <CharStyle:pod-I>Yet Another Tree Walker<CharStyle:Normal>} with name the treerexexp rule <CharStyle:pod-I>name<CharStyle:Normal>. Therefore, after compilation a subroutine <CharStyle:pod-C>wxz<CharStyle:Normal> will be available. The dot in the <CharStyle:pod-I>term<CharStyle:Normal> <CharStyle:pod-C>TIMES(., NUM)<CharStyle:Normal> matches any tree. The semantic condition states that the <CharStyle:pod-C>attr<CharStyle:Normal> entry of node <CharStyle:pod-C>NUM<CharStyle:Normal> must be zero. The <CharStyle:pod-I>transformation code<CharStyle:Normal> - that will be applied only if the matching succeeded - substitutes the whole subtree by its right child.<ParaStyle:Normal><CharStyle:Normal>References to the nodes associated with some <CharStyle:pod-C>CLASS<CharStyle:Normal> are accessed inside the semantic parts through a lexical variable <CharStyle:pod-C>$CLASS<CharStyle:Normal>. If there is more than one node the associated variable is <CharStyle:pod-C>@CLASS<CharStyle:Normal>. Variable <CharStyle:pod-C>$_[0]<CharStyle:Normal> refers to the root of the subtree that matched.<ParaStyle:Normal><CharStyle:Normal>Nodes inside a <CharStyle:pod-I>term<CharStyle:Normal> can be described using linear regular expressions like in the <CharStyle:pod-C>fold<CharStyle:Normal> transformation:<ParaStyle:perl codeblock><CharStyle:pod-C>/TIMES|PLUS|DIV|MINUS/:b(NUM, NUM)<ParaStyle:Normal><CharStyle:Normal>In such cases an optional identifier to later refer the node that matched %within semantic parts can be specified (<CharStyle:pod-C>b<CharStyle:Normal> in the example).<ParaStyle:Normal><CharStyle:Normal>Tree transformations can be grouped in families:<ParaStyle:perl codeblock><CharStyle:pod-C>algebra = fold wxz zxw neg;<ParaStyle:Normal><CharStyle:Normal>Such families - and the objects they collect - are available inside the client program (read anew the code of the driver in section \\ref{section:phases}). Thus, if <CharStyle:pod-C>$t<CharStyle:Normal> holds the AST resulting from the parsing phase, we can call its method <CharStyle:pod-C>s<CharStyle:Normal> (for substitute) with args the <CharStyle:pod-C>@algebra<CharStyle:Normal> family:<ParaStyle:perl codeblock><CharStyle:pod-C>$t-\>s(our @algebra);<ParaStyle:Normal><CharStyle:Normal>The <CharStyle:pod-C>s<CharStyle:Normal> method of <CharStyle:pod-C>Parse::Eyapp::Node<CharStyle:Normal>\\footnote{Al the classes in the AST inherit from <CharStyle:pod-C>Parse::Eyapp::Node<CharStyle:Normal>} proceeds to apply all the transformation in the family <CharStyle:pod-C>@algebra<CharStyle:Normal> to tree <CharStyle:pod-C>$t<CharStyle:Normal> until none of them matches. Thus, for input <CharStyle:pod-C>a = 2*(a+b)*(2-4/2)<CharStyle:Normal> the parser produced the tree:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> ASSIGN(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   VAR[a],<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   TIMES(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     TIMES(NUM[2],PLUS(VAR[a],VAR[b])),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     MINUS(NUM[2],DIV(NUM[4],NUM[2])<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   )<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> )<ParaStyle:perl codeblock><CharStyle:pod-C>)<ParaStyle:Normal><CharStyle:Normal>which is transformed by the call <CharStyle:pod-C>$t-\>s(@algebra)<CharStyle:Normal> in:<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(ASSIGN(VAR[a],NUM[0]))<ParaStyle:Normal><CharStyle:Normal>Resource Allocation<ParaStyle:Normal><CharStyle:Normal>The back-end of the translator starts with resource assignment. The only resource to consider here is memory. The task is remarkably simple since PIR provides an infinite number of virtual numeric registers named <CharStyle:pod-C>$N1<CharStyle:Normal>, <CharStyle:pod-C>$N2<CharStyle:Normal>, etc.<ParaStyle:perl codeblock><CharStyle:pod-C>{{ my $num = 1; # closure<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> sub new_N_register {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   return '$N'.$num++;<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> }<ParaStyle:perl codeblock><CharStyle:pod-C>}}<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C>reg_assign: $x  =\> {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> if (ref($x) =~ /VAR|NUM/) {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   $x-\>{reg} = $x-\>{attr};<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   return 1;<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> }<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> if (ref($x) =~ /ASSIGN/) {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   $x-\>{reg} = $x-\>child(0)-\>{attr};<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   return 1;<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> }<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $_[0]-\>{reg} = new_N_register();<ParaStyle:perl codeblock><CharStyle:pod-C>}<cLeading:13.000000><cFont:Arial><cLeading:><cFont:><ParaStyle:Normal><CharStyle:Normal>As it shows the code above (in file <CharStyle:pod-C>I2PIR.trg<CharStyle:Normal>), the resource allocation stage is limited to assign virtual registers to the inner nodes.<ParaStyle:Normal><CharStyle:Normal>A treeregexp term like <CharStyle:pod-C>$x<CharStyle:Normal> matches any node and creates a lexical variable <CharStyle:pod-C>$x<CharStyle:Normal> containing a reference to the node that matched.<ParaStyle:Normal><CharStyle:Normal>In between Treeregexp rules the programmer can insert Perl code between curly brackets. The code will be inserted verbatim\\footnote{Without the outer curly brackets. If it weren't for the second pair of curly brackets the lexical variable {\\tt \\$num} would be visible up to the end of the file } at that relative point by the <CharStyle:pod-C>treereg<CharStyle:Normal> compiler.<ParaStyle:Normal><CharStyle:Normal>The <CharStyle:pod-C>Parse::Eyapp::YATW<CharStyle:Normal> object <CharStyle:pod-C>$reg_assign<CharStyle:Normal> generated by the compiler is available from the main driver:<ParaStyle:perl codeblock><CharStyle:pod-C>our $reg_assign;<ParaStyle:perl codeblock><CharStyle:pod-C>$reg_assign-\>s($t);<ParaStyle:Normal><CharStyle:Normal>Now we have an AST <CharStyle:pod-I>decorated<CharStyle:Normal> with a new attribute <CharStyle:pod-C>reg<CharStyle:Normal>. See the following session with the debugger:<ParaStyle:perl codeblock><CharStyle:pod-C>$ perl -wd infix2pir.pl simple5.inf<ParaStyle:perl codeblock><CharStyle:pod-C>main::(59): my $filename = shift;<ParaStyle:perl codeblock><CharStyle:pod-C>DB\<1\> c 72    # Stop before reg assign<ParaStyle:perl codeblock><CharStyle:pod-C>-a*2                       # The input<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(TIMES(NEG(VAR),NUM))    # The AST<ParaStyle:perl codeblock><CharStyle:pod-C>main::(72): $reg_assign-\>s($t);<ParaStyle:perl codeblock><CharStyle:pod-C>DB\<2\> n<ParaStyle:perl codeblock><CharStyle:pod-C>main::(75): $t-\>bud(our @translation);<ParaStyle:perl codeblock><CharStyle:pod-C>DB\<2\> *TIMES::info = *NEG::info = \\<ParaStyle:perl codeblock><CharStyle:pod-C>*VAR::info=*NUM::info=sub {$_[0]{reg}}<ParaStyle:perl codeblock><CharStyle:pod-C>DB\<3\> $Parse::Eyapp::Node::INDENT=2<ParaStyle:perl codeblock><CharStyle:pod-C>DB\<4\> x $t-\>str       # Decorated tree<ParaStyle:perl codeblock><CharStyle:pod-C>0  '<ParaStyle:perl codeblock><CharStyle:pod-C>EXPS(<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> TIMES[$N2](<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   NEG[$N1](<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     VAR[a]<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   ),<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   NUM[2]<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> ) # TIMES<ParaStyle:perl codeblock><CharStyle:pod-C>) # EXPS'<ParaStyle:article subhead><CharStyle:Subhead>Code Generation<ParaStyle:Normal><CharStyle:Normal>The translation is approached as a particular case of <CharStyle:pod-I>tree decoration<CharStyle:Normal>. Each node is decorated with a new attribute - <CharStyle:pod-C>trans<CharStyle:Normal> - that will held the translation for such node. To compute it, we must define transformations for each of the types in the AST:<ParaStyle:perl codeblock><CharStyle:pod-C>translation = t_num t_var t_op t_neg<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>            t_assign t_list t_print;<ParaStyle:Normal><CharStyle:Normal>Some of these transformations are straightforward:<ParaStyle:perl codeblock><CharStyle:pod-C>t_num: NUM =\> {$_[0]-\>{trans}=$_[0]-\>{attr};}<ParaStyle:perl codeblock><CharStyle:pod-C>t_op: /TIMES|PLUS|DIV|MINUS/:b($left, $right)<ParaStyle:perl codeblock><CharStyle:pod-C>=\> {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> my $op = $Op{ref($b)};<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $b-\>{trans} = "$b-\>{reg} = $left-\>{reg} "<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>                ."$op $right-\>{reg}";<ParaStyle:perl codeblock><CharStyle:pod-C>}<ParaStyle:Normal><CharStyle:Normal>To keep track of the involved variables a hash is used as a rudimentary symbol table:<ParaStyle:perl codeblock><CharStyle:pod-C>{ our %s; }<ParaStyle:perl codeblock><CharStyle:pod-C>t_assign: ASSIGN($var, $exp) =\> {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $s{$var-\>{attr}} = "num"; # Type is num<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $ASSIGN-\>{trans} = "$var-\>{reg} = $exp-\>{reg}"<ParaStyle:perl codeblock><CharStyle:pod-C>}<ParaStyle:Normal><CharStyle:Normal>The translation of the root node (<CharStyle:pod-C>EXPS<CharStyle:Normal>) consists of concatenating the translations of its children:<ParaStyle:perl codeblock><CharStyle:pod-C>t_list: EXPS(@S)<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> =\> {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   $EXPS-\>{trans} = "";<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   my @trans = map { cat_trans($_) } @S;<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   $EXPS-\>{trans} =<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>     reduce { "$a\\n$b" } @trans if @trans;<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> }<ParaStyle:Normal><CharStyle:Normal>The treeregexp <CharStyle:pod-C>@S<CharStyle:Normal> matches the children of the <CharStyle:pod-C>EXPS<CharStyle:Normal> node. The associated lexical variable <CharStyle:pod-C>@S<CharStyle:Normal> contains the references to the nodes that matched.<ParaStyle:Normal><CharStyle:Normal>The method <CharStyle:pod-C>bud<CharStyle:Normal>\\footnote{\\underline{B}ottom-\\underline{U}p \\underline{D}ecorator} of <CharStyle:pod-C>Parse::Eyapp::Node<CharStyle:Normal> nodes makes a bootom up traversing of the AST applying to the node being visited the only one transformation that matches\\footnote{When {\\tt bud} is applied the family of transformations \\underline{must} constitute a <CharStyle:pod-I>partition<CharStyle:Normal> of the AST classes}. After the call <ParaStyle:perl codeblock><CharStyle:pod-C>$t-\>bud(our @translation);<ParaStyle:Normal><CharStyle:Normal>the attribute <CharStyle:pod-C>$t-\>{trans}<CharStyle:Normal> contains a translation to PIR for the whole tree.<ParaStyle:article subhead><CharStyle:Subhead>Peephole Transformations<ParaStyle:Normal><CharStyle:Normal>The name <CharStyle:pod-I>peephole optimizer<CharStyle:Normal> comes from the image of sliding a small window over the target code attempting to replace patterns of instructions by better ones. If we have a look at the code generated in the previous phase for the input <CharStyle:pod-C>a = 5-b*2<CharStyle:Normal> we see that produces:<ParaStyle:perl codeblock><CharStyle:pod-C>$N1 = b * 2<ParaStyle:perl codeblock><CharStyle:pod-C>$N2 = 5 - $N1<ParaStyle:perl codeblock><CharStyle:pod-C>a = $N2<ParaStyle:Normal><CharStyle:Normal>PIR allows memory instructions involving three arguments like <CharStyle:pod-C>a = b + c<CharStyle:Normal>. <ParaStyle:Normal><CharStyle:Normal>This fact and the observation that <CharStyle:pod-C>$N2<CharStyle:Normal> is used only once lead us to conclude that the former translation can be changed to:<ParaStyle:perl codeblock><CharStyle:pod-C>$N1 = b * 2<ParaStyle:perl codeblock><CharStyle:pod-C>a = 5 - $N1<ParaStyle:Normal><CharStyle:Normal>Perl regular expressions constitute a formidable tool to implement <CharStyle:pod-I>peephole optimization<CharStyle:Normal>. The regexp below finds patterns <ParaStyle:perl codeblock><CharStyle:pod-C>$N# = something<ParaStyle:perl codeblock><CharStyle:pod-C>IDENT = $N#<ParaStyle:Normal><CharStyle:Normal>and substitutes them by <CharStyle:pod-C>IDENT = something<CharStyle:Normal>:<ParaStyle:perl codeblock><CharStyle:pod-C>sub peephole_optimization {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $_[0] =~ <ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>  s{(\\$N\\d+)\\s*=\\s*(.*\\n)\\s*<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>    ([a-zA-Z_]\\w*)\\s*=\\s*\\1}<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C>   {$3 = $2}gx;<ParaStyle:perl codeblock><CharStyle:pod-C>}<ParaStyle:Normal><CharStyle:Normal>Emitting the code is the simplest of all the phases. Since Parrot requires all the variables to be declared, a comma separated string <CharStyle:pod-C>$dec<CharStyle:Normal>  is built concatenating the keys of the symbol table hash <CharStyle:pod-C>%s<CharStyle:Normal>. The code is then indented and the different components are articulated through a HERE document:<ParaStyle:perl codeblock><CharStyle:pod-C>sub output_code {<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> my ($trans, $dec) = @_;<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> # Indent<ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> $$trans =~ s/^/\\t/gm;<ParaStyle:perl codeblock><CharStyle:pod-C><ParaStyle:perl codeblock><CharStyle:pod-C><CharStyle:pod-C> # Output the code<ParaStyle:perl codeblock><CharStyle:pod-C>print \<\< "TRANSLATION";<ParaStyle:perl codeblock><CharStyle:pod-C>.sub 'main' :main<ParaStyle:perl codeblock><CharStyle:pod-C>\\t.local num $$dec<ParaStyle:perl codeblock><CharStyle:pod-C>$$trans<ParaStyle:perl codeblock><CharStyle:pod-C>.end<ParaStyle:perl codeblock><CharStyle:pod-C>TRANSLATION<ParaStyle:Normal><CharStyle:Normal>The call to <CharStyle:pod-C>output_code<CharStyle:Normal> finishes the job:<ParaStyle:Normal><CharStyle:Normal>output_code(\\$t-\>{trans}, \\$dec);<ParaStyle:article subhead><CharStyle:Subhead>Conclusions and Future Work<ParaStyle:Normal><CharStyle:Normal>There is a shortage of compiler toolkits in CPAN/Perl 5. It will be beneficial to have a CPAN wider covering of other compiler components: code generators as iburg \\cite{iburg} to mention just one.<ParaStyle:Normal><CharStyle:Normal>This work presented <CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal>, a work in progress in that direction. <CharStyle:pod-C>Yacc<CharStyle:Normal> and <CharStyle:pod-C>Parse::Yapp<CharStyle:Normal> programmers will feel at home in <CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal>. Additionally to the beneficial mature approach to parsing provided by <CharStyle:pod-C>Yacc<CharStyle:Normal>-like parser generators, <CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal> delivers a set of extensions that give support to the later phases of text processing.<ParaStyle:article subhead><CharStyle:Subhead>References<ParaStyle:article subhead><CharStyle:Subhead>About the Author<ParaStyle:Normal><CharStyle:Normal>Casiano Rodriguez-Leon is a Professor of Computer Science at Universidad de La Laguna. His research focuses on Parallel Computing.<ParaStyle:article subhead><CharStyle:Subhead>Acknowledgements<ParaStyle:Normal><CharStyle:Normal>This work has been supported by the {\\sc ec (feder)} and by the Spanish Ministry of Education and Science inside the `Plan Nacional de {\\sc i+d+}i' with contract number {\\sc tin2005-08818-c04-04}. Thanks To Francois Desarmenien. <CharStyle:pod-C>Parse::Eyapp<CharStyle:Normal> shares a large percentage of code with <CharStyle:pod-C>Parse::Yapp<CharStyle:Normal>.