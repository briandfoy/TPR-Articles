<ASCII-MAC>
<Version:5><FeatureSet:InDesign-Roman><ColorTable:=<Black:COLOR:CMYK:Process:0,0,0,1>>
<pstyle:Feature Section><cTypeface:Regular><cFont:Wingdings>n<cTypeface:><cFont:> Perl and Undecidability 2: Rice<0x2019>s Theorem	
<pstyle:Feature Section Lead>This winter I moved into a cabin at the edge of a frozen lake and forsook gainful employment in favor of work on a CPAN module. Currently, no generally accepted, handy tool accepts arbitrary BNF and parses with it. Recent research suggests how to create that tool. I call my effort <CharStyle:pod-C>Parse::Marpa<CharStyle:>. An alpha version is now on CPAN.
<pstyle:Feature Para>Approaching beta, I thought about potential applications. My thoughts turned to Perl 5. The Perl community had reached the consensus that Perl 5 is not statically parseable. Adam Kennedy, in the documentation for PPI, indicated how this might be proved. I worked the proof out formally and posted it on Perlmonks and also published it in this journal (XXX).
<pstyle:Feature Para>The formal proof shows that Perl 5 is not just statically unparseable, it is also dynamically unparseable. The saying had been that <0x201C>Only Perl 5 can parse Perl 5<0x201D>. In fact, not even Perl 5 can parse Perl 5 in every case.
<pstyle:Feature Para>Here<0x2019>s the reason: The only way to parse Perl 5 is to run it or to simulate it using a language of equivalent power. Perl 5 is what<0x2019>s called Turing-complete, and all Turing-complete languages are subject to the Halting Problem. There is no guarantee a Perl 5 program will ever finish running and no guarantee it will ever finish parsing itself.
<pstyle:Feature Para>In this article I will use Rice<0x2019>s Theorem to prove that Perl is unparseable. Rice<0x2019>s Theorem is powerful and easy to apply. It<0x2019>s well known in mathematical circles and deserves to be better known by programmers.
<pstyle:Feature Sub Section>Undecidable Parsing is a Feature
<pstyle:Feature Para>Undecidable parsing is not a bug. It is not a misfeature. It goes hand-in-hand with important capabilities. Understanding this is important to understanding where programming languages are going.
<pstyle:Feature Para>Perl 5 is unparseable because it gives the programmer Turing-complete power before compile time. As time goes on, it becomes clearer and clearer that Larry Wall aimed Perl in the right direction. Theoretical perfection at compile time is a loss at run-time. Industrial strength debugging and optimization require information unavailable before run-time. Decidability is not good if the decisions are bad.
<pstyle:Feature Sub Section>Decidability
<pstyle:Feature Para>Decidability means the ability for a Turing-complete machine (or language), to determine the answer to a yes/no question. A yes/no question is decidable if a Turing-complete Perl script can answer it. Otherwise it is undecidable.
<pstyle:Feature Para>Turing-equivalence means equivalence to the model of computing in Alan Turing<0x2019>s 1936 paper. A machine or language is Turing-complete if it has Turing-equivalent power or better. All modern general-purpose machines and languages are at least Turing-complete.
<pstyle:Feature Para>Perl scripts differ from theoretical Turing-complete programs in two ways, neither of them serious obstacles to Rice<0x2019>s Theorem. First, Turing-complete machines and programs have unlimited memory. The equivalent Perl implementation would never run out of memory. A real-life Perl script will fail to answer an undecidable question by running out of memory. Its theoretical Turing-complete counterpart fails by running forever. This is not a difference we need to care about.
<pstyle:Feature Para>Second, Perl scripts have certain capabilities which Turing-equivalent machines do not. Turing-equivalent machines and languages must be completely predictable -- deterministic. Perl has unpredictable features like its <CharStyle:pod-C>rand<CharStyle:> builtin. Pedantically, <CharStyle:pod-C>rand<CharStyle:> is pseudo-random instead of random, but from the point of view of the Perl script <CharStyle:pod-C>rand<CharStyle:> is close enough to random. Perl<0x2019>s ability to interact with outside processes and across networks means many Perl calls behave unpredictably, perhaps even in the quantum mechanical sense.
<pstyle:Feature Para>But unpredictability is no obstacle to undecidability proofs. An undecidable question does not become decidable when its subject matter becomes unpredictable.
<pstyle:Feature Sub Section>Undecidability
<pstyle:Feature Para>Rices Theorem states that every interesting question about what a Perl script does is undecidable.
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Does a Perl script ever print the character <0x2019>0<0x2019>?<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Does a Perl script write to STDERR?<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Is a Perl script<0x2019>s output the same as its input?<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Does a Perl script fork a shell?<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>Does a Perl script contain a virus?<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>All of these questions can be proved to be undecidable using Rice<0x2019>s Theorem. Here is Rice<0x2019>s Theorem more formally:
<pstyle:Feature Para><CharStyle:pod-B>Any question about what an arbitrary Perl script does with an arbitrary input is undecidable, unless it is trivial.<CharStyle:>
<pstyle:Feature Sub Section>Trivial?
<pstyle:Feature Para>For the purposes of Rice<0x2019>s Theorem, a question is trivial if the answer is always <0x201C>yes<0x201D>, or if the answer is always <0x201C>no<0x201D>. A trivial question is one which is true or false regardless of the Perl script I<0x2019>m asking about.
<pstyle:Feature Para>An example of a trivial question is <0x201C>Will the output of this Perl script be zero or more characters in length?<0x201D> This answer has to be <0x201C>yes<0x201D>. The opposite question (<0x201C>Will the output of this Perl script be negative in length?<0x201D>) will always be <0x201C>no<0x201D>. It also is a trivial question. The opposite of any trivial question will always be another trivial question.
<pstyle:Feature Sub Section><0x201C>Is<0x201D> Versus <0x201C>Does<0x201D>
<pstyle:Feature Para>For a question to be proved undecidable by Rice<0x2019>s Theorem, it must be about what a Perl script <CharStyle:pod-B>does<CharStyle:>. It cannot merely be about what a Perl script <CharStyle:pod-B>is<CharStyle:>. For example, Rice<0x2019>s Theorem applies if I am asking <0x201C>Does a Perl script ever print the character <0x2019>0<0x2019>?<0x201D>. Rice<0x2019>s Theorem does not apply if the question is <0x201C>Does a Perl script contain the character <0x2019>0<0x2019>?<0x201D>.
<pstyle:Feature Para>The mathematician<0x2019>s way to say this is that Rice<0x2019>s Theorem applies only to questions about <CharStyle:pod-B>partial functions<CharStyle:>. Ignore the <0x201C>partial<0x201D> in <0x201C>partial function<0x201D> for the moment. Programmers know what a partial function is, if not always by that name. I want to look carefully at the term <0x201C>function<0x201D> first.
<pstyle:Feature Para><CharStyle:pod-B>A function is a mapping of each member of a set of inputs to exactly one output.<CharStyle:>
<pstyle:Feature Para>The requirement that each input have exactly one output is important. The Perl subroutine
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    sub successor { (shift)+1 }<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>implements a function. (I am ignoring overflow issues.) The answer for 1 can only be 2. The answer for -1 can only be 0. Every input to <CharStyle:pod-C>successor<CharStyle:> has a most one output.
<pstyle:Feature Para>Constant functions are functions which have the same output for all inputs. Here<0x2019>s one:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    sub the_answer { 42 }<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>A function must have exactly one output for each input. The outputs do not have to be unique to each input. Constant functions, where the output is always the same, are quite acceptable as functions for the purposes of Rice<0x2019>s Theorem.
<pstyle:Feature Para>Perl subroutines can be functions, and are sometimes called functions. Unless I make it clear otherwise, from here on out <0x201C>function<0x201D> will mean the partial function performed by a Perl script.
<pstyle:Feature Sub Section>Partial Functions
<pstyle:Feature Para>Computer scripts, programs and subroutines are <CharStyle:pod-I>partial<CharStyle:> functions. A partial function is a function which might fail to produce an output.
<pstyle:Feature Para>The classic way for a program to fail to produce an output is for it to loop forever. It<0x2019>s a convenient example, because it<0x2019>s implementation-independent. Every general-purpose method of programming a computer is capable of infinite loops.
<pstyle:Feature Para>I can also say that if a Perl script returns an exit code other than zero, it fails to produce an output. If I do that, it becomes hard to take into account output from the Perl script prior to exit. How to best define output depends on the proof.
<pstyle:Feature Sub Section>Predictability
<pstyle:Feature Para>One Perl script which does <CharStyle:pod-B>not<CharStyle:> implement a function is
<pstyle:Feature Para>say rand(42)
<pstyle:Feature Para>This script fails to implement a function because, for any given input, it can produce many different outputs.
<pstyle:Feature Para>This means a Perl script with <CharStyle:pod-C>rand<CharStyle:> or any other unpredictable system call may fail to implement a function, and therefore strictly speaking will be outside the scope of Rice<0x2019>s Theorem. In fact, undecidability results apply as much to unpredictable scripts as to predictable ones.
<pstyle:Feature Sub Section>Applying Rice<0x2019>s Theorem
<pstyle:Feature Para>Suppose these five things are known:
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>1<cLeading:><pstyle:Feature Para>A definition of the <CharStyle:pod-B>input<CharStyle:> to Perl scripts.
<cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>2<cLeading:><pstyle:Feature Para>A definition of the <CharStyle:pod-B>output<CharStyle:> from Perl scripts.
<cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>3<cLeading:><pstyle:Feature Para>A yes/no <CharStyle:pod-B>question<CharStyle:> about the output of Perl scripts. The question must look at the scripts as if they were partial functions.
<cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>4<cLeading:><pstyle:Feature Para>A <CharStyle:pod-B>case<CharStyle:> of a Perl script and an input for which the answer to the question is <CharStyle:pod-B><0x201C>yes<0x201D><CharStyle:>.
<cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>5<cLeading:><pstyle:Feature Para>A <CharStyle:pod-B>case<CharStyle:> of a Perl script and an input for which the answer to the question is <CharStyle:pod-B><0x201C>no<0x201D><CharStyle:>.

<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>If we have all five conditions, then Rice<0x2019>s Theorem tells us that the yes/no question is undecidable.
<pstyle:Feature Para>Carefully defining input and output is necessary. In some proofs, the input and output will be the only conditions that are not obvious.
<pstyle:Feature Sub Section>Undecidable: Does a Perl Script Print <0x2019>0<0x2019>?
<pstyle:Feature Para>Definition of the <CharStyle:pod-B>Input<CharStyle:>: The characters available on STDIN.
<pstyle:Feature Para>Definition of the <CharStyle:pod-B>Output<CharStyle:>: The characters written to STDOUT.
<pstyle:Feature Para>The <CharStyle:pod-B>Question<CharStyle:> to be Decided: For any input and any perl script, does it print the character <0x2019>0<0x2019> as part of its output?
<pstyle:Feature Para>A <CharStyle:pod-B>Case<CharStyle:> where the Answer is <CharStyle:pod-B><0x201C>No<0x201D><CharStyle:>: The empty Perl script with empty input.
<pstyle:Feature Para>A <CharStyle:pod-B>Case<CharStyle:> where the Answer is <CharStyle:pod-B><0x201C>Yes<0x201D><CharStyle:>: The Perl script script <0x201C><CharStyle:pod-C>say 0<CharStyle:><0x201D> with empty input.
<pstyle:Feature Para>The question to be decided is clearly about the output as a function. The two cases show that it is non-trivial. By Rice<0x2019>s Theorem the question is undecidable. <CharStyle:pod-B>QED<CharStyle:>. (<0x201C>QED<0x201D> is the traditional way to indicate the end of a proof.)
<pstyle:Feature Para>The <0x201C>empty Perl script<0x201D> is the zero length Perl script. I<0x2019>ll use the empty Perl script as much as I can.
<pstyle:Feature Para>The empty input is the zero length input. In this case, the question does not compare input and output.
<pstyle:Feature Sub Section>Undecidable: Is a Perl Script<0x2019>s Output the Same as its Input?
<pstyle:Feature Para><CharStyle:pod-B>Input:<CharStyle:> The characters available on STDIN.
<pstyle:Feature Para><CharStyle:pod-B>Output:<CharStyle:> The characters written to STDOUT.
<pstyle:Feature Para><CharStyle:pod-B>Question:<CharStyle:> Given a Perl script, will the output ever be the same as the input?
<pstyle:Feature Para><CharStyle:pod-B><0x201C>No<0x201D> Case:<CharStyle:> The empty Perl script with any input of length greater than 0.
<pstyle:Feature Para><CharStyle:pod-B><0x201C>Yes<0x201D> Case:<CharStyle:> The empty Perl script with the empty input.
<pstyle:Feature Para><CharStyle:pod-B>QED.<CharStyle:>
<pstyle:Feature Para>Proofs like this and the previous proof can be constructed for any non-trivial question about STDOUT as a function of STDIN.
<pstyle:Feature Sub Section>Undecidable: Does a Perl Script Write to STDERR?
<pstyle:Feature Para><CharStyle:pod-B>Input:<CharStyle:> The characters available on STDIN.
<pstyle:Feature Para><CharStyle:pod-B>Output:<CharStyle:> The characters written to STDERR.
<pstyle:Feature Para><CharStyle:pod-B>Question:<CharStyle:> For any Perl script and any input, does the script with that input write to STDERR?
<pstyle:Feature Para><CharStyle:pod-B><0x201C>No<0x201D> Case:<CharStyle:> The empty Perl script.
<pstyle:Feature Para><CharStyle:pod-B><0x201C>Yes<0x201D> Case:<CharStyle:> <0x201C><CharStyle:pod-C>say STDERR 42<CharStyle:><0x201D>.
<pstyle:Feature Para>This question is clearly about the output as a function. Rice<0x2019>s Theorem applies. <CharStyle:pod-B>QED.<CharStyle:>
<pstyle:Feature Sub Section>Undecidable: Does a Perl Script Fork a Shell Command?
<pstyle:Feature Para>Not all Perl variants are capable of <CharStyle:pod-C>fork<CharStyle:><0x2019>ing, and some don<0x2019>t have shells available. This proof requires an additional assumption:
<pstyle:Feature Para><CharStyle:pod-B>There are Perl scripts which <CharStyle:pod-C>fork<CharStyle:> and <CharStyle:pod-C>exec<CharStyle:> shell commands, and at least one shell command can be identified by its name.<CharStyle:>
<pstyle:Feature Para>With this assumption I can proceed as usual:
<pstyle:Feature Para><CharStyle:pod-B>Input:<CharStyle:> Characters available on STDIN (but actually not relevant).
<pstyle:Feature Para><CharStyle:pod-B>Output:<CharStyle:> A trace of <CharStyle:pod-C>fork<CharStyle:> and <CharStyle:pod-C>exec<CharStyle:> commands, including the name of the command <CharStyle:pod-C>exec<CharStyle:><0x2019>d.
<pstyle:Feature Para><CharStyle:pod-B>Question:<CharStyle:> For any Perl script and any input, does the script with that input <CharStyle:pod-C>fork<CharStyle:> and <CharStyle:pod-C>exec<CharStyle:> a shell command?
<pstyle:Feature Para><CharStyle:pod-B><0x201C>No<0x201D> Case:<CharStyle:> The empty Perl script.
<pstyle:Feature Para><CharStyle:pod-B><0x201C>Yes<0x201D> Case:<CharStyle:> By the assumption above, there is a script that <CharStyle:pod-C>fork<CharStyle:><0x2019>s and <CharStyle:pod-C>exec<CharStyle:><0x2019>s a shell command.
<pstyle:Feature Para>The question is clearly about the output, and is non-trivial. <CharStyle:pod-B>QED<CharStyle:>.
<pstyle:Feature Para>This proof uses a really nice technique which I learned from the next proof. I don<0x2019>t define the term <0x201C>shell command<0x201D>. It<0x2019>s not necessary or useful to do so. All the proof needs is the assumption that there is such a thing as a shell command. With that I can ignore the issue of exactly what is or is not a shell.
<pstyle:Feature Para>I can substitute the term <0x201C>interesting command<0x201D> for <0x201C>shell comand<0x201D> in the proof and its assumption. The new proof shows that it is undecidable whether a Perl script <CharStyle:pod-C>fork<CharStyle:><0x2019>s and <CharStyle:pod-C>exec<CharStyle:><0x2019>s any interesting commands. Which commands I call <0x201C>interesting<0x201D> is up to me.
<pstyle:Feature Sub Section>Undecidable: Does a Perl Script Contain a Virus?
<pstyle:Feature Para>The ideas in this proof are from William Dowling. Dowling didn<0x2019>t define virus. He assumed a few things about viruses:
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>1<cLeading:><pstyle:Feature Para>Viruses infect systems, in the process changing memory, disk, or some other kind of readable storage.
<cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>2<cLeading:><pstyle:Feature Para>It is possible to write a Perl script that is a virus.
<cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>2<cLeading:><pstyle:Feature Para>At least one Perl script is not a virus.

<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000><CharStyle:pod-B>Input:<CharStyle:> A dump of readable storage as it existed when the Perl script started.
<pstyle:Feature Para><CharStyle:pod-B>Output:<CharStyle:> A listing of all the changes to readable storage caused by the Perl script.
<pstyle:Feature Para><CharStyle:pod-B>Question:<CharStyle:> For any Perl script and any input, is the Perl script with that input a virus?
<pstyle:Feature Para><CharStyle:pod-B><0x201C>No<0x201D> Case:<CharStyle:> Above, I assumed that one Perl script is not a virus. For this Perl script and some input, the answer is <0x201C>no<0x201D>.
<pstyle:Feature Para><CharStyle:pod-B><0x201C>Yes<0x201D> Case:<CharStyle:> I assumed that a virus could be written in Perl. So for a least one Perl script and any input, the answer is <0x201C>yes<0x201D>.
<pstyle:Feature Para>I assumed that viruses change readable storage, so the question is about the output of a Perl script as a function. All the conditions of Rice<0x2019>s Theorem are fulfilled. I cannot decide, in general, whether a Perl script will infect readable storage. Therefore I can<0x2019>t know if it<0x2019>s a virus. <CharStyle:pod-B>QED.<CharStyle:>
<pstyle:Feature Para>This proof looks at input and output from a different angle -- as snapshots of the system. I don<0x2019>t deal with standard input. I<0x2019>ve never heard of a virus that waited for a say-so from the user. If I want to allow for the possibility of polite viruses, I can modify the definition of input to include user input.
<pstyle:Feature Para>In real-life, some of the changes to readable storage won<0x2019>t be made by the Perl script. Even if I forbid other applications, system processes might make changes. That<0x2019>s why the output includes only changes to readable storage made by the Perl script. I could use tracing to determine which changes those are.
<pstyle:Feature Para>But the proof still works, even if I can never figure out which process caused what change. Here<0x2019>s why: From the full listing of all changes to readable storage by all processes, I can generate a set of listings, one for every possible choice among the changes. One listing in this set is the one that contains all the changes caused by the Perl script, and only those changes. The proof works if I use that one. Since I know that listing exists, I know the proof works, even if I don<0x2019>t know which listing the proof needs.
<pstyle:Feature Para>In all these proofs, I don<0x2019>t have to show how I would compute the inputs and outputs for a real-life example. The inputs and outputs have to actually exist. But I don<0x2019>t have to know how to compute them.
<pstyle:Feature Sub Section>Does a Perl Script Contain a Bug?
<pstyle:Feature Para>A beauty of the Virus Proof is its minimal assumptions. Anything I might want to call a virus fits the assumptions. So do a lot of things I would not call viruses. That<0x2019>s OK. It<0x2019>s just fine if the Virus Proof proves more than it sets out to prove.
<pstyle:Feature Para>Replacing the word <0x201C>virus<0x201D> with <0x201C>bug<0x201D> turns the Virus Proof into a proof that no Perl script can find all the bugs in another, arbitrary, Perl script. Once again, only a few basic assumptions about bugs are needed, not a definition.
<pstyle:Feature Para>One additional change to the Virus Proof might be necessary for it to make a Better Bug Proof. Viruses <0x201C>infect<0x201D>, and therefore leave some trace in, readable storage. Bugs can show up as volatile output, such as to screen displays. Bugs can also show up in non-machine-readable forms, such as the output of printers. To include bugs which show up only on screens and in printouts, I can broaden the output definition. One way would be to include a trace of all writes to unreadable or volatile media.
<pstyle:Feature Sub Section>Questions about Specific Scripts
<pstyle:Feature Para>It<0x2019>s time to look at questions that Rice<0x2019>s Theorem does not apply to. For Rice<0x2019>s theorem to apply, the question had to be about partial functions <CharStyle:pod-B>in general<CharStyle:>. If I<0x2019>m only asking about some partial functions or some Perl scripts, then Rice<0x2019>s Theorem does not apply, at least not directly.
<pstyle:Feature Para>For example, above I proved that it is undecidable in the general case whether a Perl script prints the digit <0x201C>0<0x201D>. Does that mean that I can<0x2019>t decide that the Perl script
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>     say 0<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>prints 0? Not at all. Similarly,
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>     say 42<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>does not print 0 and I can decide that.
<pstyle:Feature Para>Rice<0x2019>s Theorem does not apply to questions about specific Perl scripts. Rice<0x2019>s Theorem also does not apply to questions about finite sets of Perl scripts. Rice<0x2019>s Theorem only directly applies to questions that are about all functions performed by Perl scripts.
<pstyle:Feature Para>While, pedantically speaking, Rice<0x2019>s Theorem can<0x2019>t be used to answer questions about subclasses of Perl scripts, logic hacks can work around that restriction. If I use logical connectives (and<0x2019>s, or<0x2019>s and not<0x2019>s), and multiple questions, I can formulate questions about all Perl scripts that imply the answers to questions that are only about subclasses of Perl scripts.
<pstyle:Feature Para>I can indirectly apply Rice<0x2019>s Theorem to any question about any subclass of Perl scripts, if
<cLeading:5.400000>
<cLeading:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>The subclass is defined by a partial function.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>The subclass is non-trivial. (There is at least at least one Perl script and one input not in the subclass.)<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>The question is about a partial function.<cLeading:><cLeading:5.400000>
<cLeading:><pLeftIndent:><pFirstLineIndent:><bnListType:><ParaStyle:Feature Section Lead><pLeftIndent:10.000000><pFirstLineIndent:10.000000><bnListType:Bullet><cLeading:5.400000>The question is non-trivial for that subclass. (There<0x2019>s a Perl script and an input in the subclass for which the answer is yes, and another Perl script and an input in the subclass for which the answer is no.)<cLeading:>
<pLeftIndent:><pFirstLineIndent:><bnListType:><pstyle:Feature Para><pSpaceBefore:4.500000>For example, pedantically speaking, in Rice<0x2019>s Theorem, I can<0x2019>t restrict the question about writing to STDERR only to scripts which open sockets. But I can ask if it is decidable whether a script which opens a socket, also writes on STDERR. (Using logical connectives and pseudo-code, this would be <CharStyle:pod-C>NOT opens_socket OR writes_stderr<CharStyle:>.) I can also ask if it is decidable whether a script which opens a socket does not write on STDERR. (<CharStyle:pod-C>NOT opens_socket OR NOT writes_stderr<CharStyle:>.) Rice<0x2019>s Theorem applies to both these questions, and they are undecidable. This tells me that the question of whether Perl scripts write to STDERR is undecidable, even if I am limiting consideration to Perl scripts which open sockets.
<pstyle:Feature Sub Section><0x201C>Is<0x201D> Versus <0x201C>Does<0x201D>: The Litmus Test
<pstyle:Feature Para>In many cases it<0x2019>s clear what is meant by the difference between what a script <0x201C>does<0x201D> (the partial function it implements) and what a script <0x201C>is<0x201D> (properties of the script which are not properties of the partial function.) But not always. For example, take the question:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>     Is the script recursive?<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>This is an <0x201C>is<0x201D> question, and Rice<0x2019>s Theorem does <CharStyle:pod-B>not<CharStyle:> apply. Intuitively, this might seem like a <0x201C>does<0x201D> question and it might seem that Rice<0x2019>s Theorem should apply.
<pstyle:Feature Para>Fortunately, there<0x2019>s a litmus test:
<pstyle:Feature Para><CharStyle:pod-B>If any two Perl scripts which implement the same function have different answers to a question, then that question is an <0x201C>is<0x201D> question, and Rice<0x2019>s Theorem does not apply. Otherwise, it<0x2019>s a <0x201C>does<0x201D> question, and Rice<0x2019>s Theorem does apply.<CharStyle:>
<pstyle:Feature Para>If I can find a function which has both a recursive solution and a non-recursive solution, that will be enough to show that the question <0x201C>Is the script recursive?<0x201D> is one of those not addressed by Rice<0x2019>s Theorem. Many problems have both recursive and non-recursive solutions. Rather than use an elegant pair, I<0x2019>ll settle for a simple example. The code below copies a single line from STDIN to STDOUT. Nobody in their right mind would solve this problem recursively, especially in Perl. But here it is:
<pstyle:Feature Code Para><pSpaceBefore:4.500000>    sub inefficient {
<pSpaceBefore:><pstyle:Feature Code Para>return unless @_;
<pstyle:Feature Code Para>print (shift);
<pstyle:Feature Code Para>inefficient(@_)
<pstyle:Feature Code Para>    }
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    inefficient(split //, \<STDIN\>)
<pSpaceAfter:><pstyle:Feature Para>This same function is implemented much more nicely by the following non-recursive script:
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    print<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>This demonstrates that the question of whether or not a Perl script is recursive is not about partial functions, and therefore is not a question whose decidability Rice<0x2019>s Theorem can determine.
<pstyle:Feature Sub Section>Decidable: Does a Perl script run longer than <CharStyle:pod-B>N<CharStyle:> seconds?
<pstyle:Feature Para>If a Perl script implementing a partial function runs in less than <CharStyle:pod-B>N<CharStyle:> seconds, I can write a slower one that implements the same partial function. I can write it less efficiently, or I can just insert pointless logic. Since I can write two scripts which perform the same partial function, but have different answers to the question, clearly the question of run-time length is not about the partial function. Rice<0x2019>s Theorem does not apply.
<pstyle:Feature Para>Pedantically, If <CharStyle:pod-B>N<CharStyle:> is less than Perl<0x2019>s start-up time, Rice<0x2019>s Theorem does apply, because every script produces the same answer. That means every script for every partial function produces the same answer, and technically speaking, the question is about partial functions. But in that case the answer to the question is always <0x201C>yes<0x201D>, so the question is trivial. Rice<0x2019>s Theorem applies to trivial questions, but it does not prove undecidability for them.
<pstyle:Feature Para>I can easily to decide whether a Perl script takes <CharStyle:pod-B>N<CharStyle:> seconds to run or not. I start the script and time it. But for one question about about how long a Perl script runs, Rice<0x2019>s does prove undecidability. That<0x2019>s the question of whether a Perl script runs forever -- the Halting Question.
<pstyle:Feature Para>For the Halting Question, all scripts implementing the same partial function have the same answer. When the question is whether the program will run forever, making the script less efficient doesn<0x2019>t change the answer. Timing a Perl script doesn<0x2019>t help. Timings cannot reliably tell the difference between Perl scripts which run forever, and Perl scripts which halt after running for a very long time. For the Halting Question, Rice<0x2019>s Theorem applies and proves undecidability.
<pstyle:Feature Sub Section>Proof: Perl Is Unparseable
<pstyle:Feature Para>This proof depends on a parsing ambiguity illustrated in the following elegant example, which is taken from a posting by ikegami on perlmonks.
<pstyle:Feature Code Para><pSpaceBefore:4.500000>    $ perl -E 'sub dunno { 3 } say dunno + 4'
<pSpaceBefore:><pstyle:Feature Code Para>    3
<pstyle:Feature Code Para>    $ perl -E 'sub dunno() { 3 } say dunno + 4'
<pstyle:Feature Code Para><pSpaceAfter:4.500000>    7
<pSpaceAfter:><pstyle:Feature Para>In both commands the <CharStyle:pod-C>dunno<CharStyle:> subroutine returns 3, ignoring any argument it is passed. In the first, there is no prototype, so that <0x201C><CharStyle:pod-C>dunno + 4<CharStyle:><0x201D> is parsed as a call to <CharStyle:pod-C>dunno<CharStyle:> with <CharStyle:pod-C>+4<CharStyle:> as its argument. The <CharStyle:pod-C>+4<CharStyle:> is discarded and the command prints <0x201C><CharStyle:pod-C>3<CharStyle:><0x201D>.
<pstyle:Feature Para>In the second command, there is a nullary prototype, and the plus sign in <0x201C><CharStyle:pod-C>dunno + 4<CharStyle:><0x201D> is parsed as a binary operator. <CharStyle:pod-C>dunno<CharStyle:> is passed no arguments and the 3 which it returns is added to the 4. The result is <0x201C><CharStyle:pod-C>7<CharStyle:><0x201D>.
<pstyle:Feature Para>This proof will proceed by showing that it<0x2019>s undecidable whether <CharStyle:pod-C>dunno<CharStyle:> has no prototype, as in the first command, or a nullary prototype, as in the second. Without knowing how <CharStyle:pod-C>dunno<CharStyle:> is prototyped, I can<0x2019>t know how the lines of Perl in the example above are parsed. Since <CharStyle:pod-C>dunno<CharStyle:><0x2019>s prototype is undecidable, the parses of the lines above are undecidable. Since the parses of the lines above are undecidable, Perl parsing in general is undecidable.
<pstyle:Feature Para><CharStyle:pod-B>Input:<CharStyle:> Not relevant.
<pstyle:Feature Para><CharStyle:pod-B>Output:<CharStyle:> A printout showing how some Perl test code would be parsed, when preceded by the Perl code in question. This could be obtained by concatenating the test code to the Perl code in question, running the combined code with the <CharStyle:pod-C>-MOConcise,-terse<CharStyle:> flags, then extracting the parse for the test code from the output.
<pstyle:Feature Para><CharStyle:pod-B>Question:<CharStyle:> For any Perl code, any input, and the test code <0x201C><CharStyle:pod-C>say dunno + 4<CharStyle:><0x201D>, does the plus sign in the test code parse as a binary operator?
<pstyle:Feature Para><CharStyle:pod-B><0x201C>No<0x201D> case:<CharStyle:>
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    BEGIN { *dunno = sub { 3 } }<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para><CharStyle:pod-B><0x201C>Yes<0x201D> case:<CharStyle:>
<pstyle:Feature Code Para><pSpaceAfter:4.500000><pSpaceBefore:4.500000>    BEGIN { *dunno = sub () { 3 } }<pSpaceBefore:>
<pSpaceAfter:><pstyle:Feature Para>The question is about the output of constant functions, and is non-trival. So the parse of the test code is undecidable. <CharStyle:pod-B>QED<CharStyle:>.
<pstyle:Feature Para>There<0x2019>s a special requirement in this proof. The output in this proof is a parse, and a parse is produced <CharStyle:pod-B>before run-time<CharStyle:>. I must show that I can use Turing-complete Perl code to determine the prototype of the <CharStyle:pod-C>dunno<CharStyle:> subroutine at compile time.
<pstyle:Feature Para>A function definition won<0x2019>t work. Function definitions take effect before the execution of any Perl code, even the code in BEGIN blocks. For Turing-complete Perl to choose <CharStyle:pod-C>dunno<CharStyle:><0x2019>s prototype, I need to establish the prototype before the test code is compiled, but I cannot use a function definition.
<pstyle:Feature Para>In the non-triviality conditions, I set up prototypes for anonymous subroutines. I give the anonymous subroutine of my choice the name <CharStyle:pod-C>dunno<CharStyle:> using symbol table manipulation. I do this in a BEGIN block, it is available at compile time, and it affects the parse of the test code.
<pstyle:Feature Para>Larry says there is more than one way to do it. Even a ragged-edge hack like this is no exception. Another way to set up the prototypes is to put function definitions into strings. The strings can be <CharStyle:pod-C>eval<CharStyle:><0x2019>ed in a <CharStyle:pod-C>BEGIN<CharStyle:> block. The <CharStyle:pod-C>eval<CharStyle:><0x2019>ed function definitions will be available when the test code is compiled. Their prototypes will affect the parse.
<pstyle:Feature Sub Section>How Rice<0x2019>s Theorem is Proved
<pstyle:Feature Para>I won<0x2019>t prove Rice<0x2019>s Theorem here. It is proved twice in the Wikipedia article on Rice<0x2019>s Theorem, once informally and once with some rigor. The Rice<0x2019>s proof is very similar to the one for the Halting Theorem, which I gave in Perl-ish form in the first article of this series. In the next article in this series, I will give another proof that Perl is unparseable. That proof that will follow the same strategy as the two Wikipedia proofs of Rice<0x2019>s Theorem.
<pstyle:Feature Para>The <0x201C>Formal Statement<0x201D> in the Wikipedia article on Rice<0x2019>s Theorem describes the partial functions using integers as their input and output. I use strings to represent input and output. So do the proofs in the Wikipedia article. For an actual implementation, strings would be far superior. But integers have been standard in math.
<pstyle:Feature Para>Integer and string representations of input and output are equivalent. Each can be mapped to the other in many ways. One way to map every integer to a string is after the fashion of <CharStyle:pod-C>Math::BigInt::bstr()<CharStyle:>.
<pstyle:Feature Para>At machine level, every string is already represented as a number. I could implement the mapping of an arbitrary length string to an integer by taking the numerical value of each character of a string and using <CharStyle:pod-C>Math::Bigint<CharStyle:> to do arbitrary precision shifts and adds. That would still fail to capture the full theoretical concept, since the Perl implementation won<0x2019>t have infinite memory available to it. But it<0x2019>s not necessary to indicate how to write these mappings in Perl. All that is needed is to show that mappings exist.
<pstyle:Feature Para>The <0x201C>Formal Statement<0x201D> in the Wikipedia article on Rice<0x2019>s Theorem also refers to G<0x00f6>del-encoding. A G<0x00f6>del encoding is a way of representing partial functions as integers. Every partial function has at least one Perl script that represents it, and this is an easy and efficient G<0x00f6>del encoding of partial functions to strings. For a G<0x00f6>del encoding to integers, the Perl scripts can in turn be mapped to integers, just like any other strings.
<pstyle:Feature Sub Section>Conclusion
<pstyle:Feature Para>Rice<0x2019>s Theorem is flexible and has wide applications. Results come easily. So easily that Rice<0x2019>s can seem like a <0x201C>black box<0x201D>. Out pops the answer, but sometimes no feeling for why the proof is true pops out along with it.
<pstyle:Feature Para>In the next and last article in this series, I will go back to basics. I will prove the Perl unparseability result without invoking Rice<0x2019>s Theorem. This proof will be similar to that given for the Halting Theorem in my first article, and will bring us full circle.
<pstyle:Feature Sub Section>References
<pstyle:Feature Para>William Dowling<0x2019>s Virus Proof: <0x201C>There Are No Safe Virus Tests<0x201D>, William Dowling, <CharStyle:pod-I>American Mathematical Monthly<CharStyle:>, v.96 n.9, p.835-836, Nov. 1989. ISSN 0002-9890. <CharStyle:pod-I>http://vx.netlux.org/lib/awd00.html<CharStyle:>
<pstyle:Feature Para>Rice<0x2019>s Theorem: <CharStyle:pod-I>http://en.wikipedia.org/wiki/Rice%27s_Theorem<CharStyle:>
<pstyle:Feature Para>Turing Completeness: <CharStyle:pod-I>http://en.wikipedia.org/wiki/Turing_completeness<CharStyle:>
<pstyle:Feature Para>ikegami<0x2019>s elegant example of parsing ambiguity in Perl, from Perlmonks: <CharStyle:pod-I>http://perlmonks.org/?node_id=688260<CharStyle:>
<pstyle:Feature Para><0x201C>Perl Cannot Be Parsed: A Formal Proof<0x201D>, my original Perlmonks post on Perl<0x2019>s unparseability: <CharStyle:pod-I>http://www.perlmonks.org/?node_id=663393<CharStyle:>
<pstyle:Feature Para>My general BNF parser, currently in alpha: <CharStyle:pod-I>http://search.cpan.org/dist/Parse-Marpa<CharStyle:>
<pstyle:Feature Para>Adam Kennedy<0x2019>s PPI module: <CharStyle:pod-I>http://search.cpan.org/dist/PPI<CharStyle:>
